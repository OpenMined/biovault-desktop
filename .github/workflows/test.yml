name: Test

on:
  workflow_dispatch:
  push:
    branches:
      - "main"
      - "dev"
  pull_request:
    branches:
      - "**"

concurrency:
  group: ${{ github.workflow }}-${{ github.ref_name }}
  cancel-in-progress: true

jobs:
  configure-build-matrix:
    name: Determine build targets
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
      has-targets: ${{ steps.set-matrix.outputs.has-targets }}
    steps:
      - name: Build matrix
        id: set-matrix
        run: |
          python - <<'PY'
          import json
          import os

          entries = [
              {
                  'runs-on': 'macos-latest',
                  'args': 'aarch64-apple-darwin',
                  'build_kind': 'tauri',
                  'target': 'macos-arm64',
              },
              {
                  'runs-on': 'macos-latest',
                  'args': 'x86_64-apple-darwin',
                  'build_kind': 'tauri',
                  'target': 'macos-x64',
              },
              {
                  'runs-on': 'windows-latest',
                  'args': 'x86_64-pc-windows-msvc',
                  'build_kind': 'tauri',
                  'target': 'windows-x64',
              },
              {
                  'runs-on': 'ubuntu-22.04',
                  'args': 'x86_64-unknown-linux-gnu',
                  'build_kind': 'tauri',
                  'target': 'linux-x64',
              },
              {
                  'runs-on': 'ubuntu-22.04-arm64',
                  'args': 'aarch64-unknown-linux-gnu',
                  'build_kind': 'tauri',
                  'target': 'linux-arm64',
              },
          ]

          matrix = {'include': entries}
          has_targets = 'true'

          with open(os.environ['GITHUB_OUTPUT'], 'a', encoding='utf-8') as fh:
              fh.write(f"matrix={json.dumps(matrix)}\n")
              fh.write(f"has-targets={has_targets}\n")
          PY

  build:
    name: Build app bundle
    needs:
      - configure-build-matrix
    if: ${{ needs.configure-build-matrix.outputs.has-targets == 'true' }}
    strategy:
      fail-fast: false
      matrix: ${{ fromJSON(needs.configure-build-matrix.outputs.matrix) }}
    runs-on: ${{ matrix.runs-on }}
    env:
      APPLE_ID: ${{ secrets.APPLE_ID }}
      APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
      APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
      APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
      TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
      TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
      GH_TOKEN: ${{ github.token }}
      APPIMAGE_EXTRACT_AND_RUN: "1"
      TAURI_CLI_LOG_LEVEL: trace
    steps:
      - name: Enable git long paths (Windows)
        if: runner.os == 'Windows'
        run: git config --global core.longpaths true

      - name: Checkout project
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Set up Docker Buildx
        if: matrix.build_kind == 'docker'
        uses: docker/setup-buildx-action@v3

      - name: Cache Docker layers
        if: matrix.build_kind == 'docker'
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-arm64-${{ hashFiles('docker/linux_arm64/Dockerfile') }}
          restore-keys: |
            ${{ runner.os }}-buildx-arm64-

      - name: Import signing certificate into keychain
        if: runner.os == 'macOS'
        uses: apple-actions/import-codesign-certs@v3
        with:
          p12-file-base64: ${{ secrets.SIGNING_CERTIFICATE_P12_DATA }}
          p12-password: ${{ secrets.SIGNING_CERTIFICATE_PASSWORD }}

      - name: Install system dependencies (Linux)
        if: runner.os == 'Linux' && matrix.build_kind == 'tauri'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libwebkit2gtk-4.1-dev \
            build-essential \
            pkg-config \
            curl \
            xdg-utils \
            wget \
            file \
            libxdo-dev \
            libssl-dev \
            libayatana-appindicator3-dev \
            librsvg2-dev \
            libsqlite3-dev \
            libfuse2 \
            patchelf \
            libgtk-3-dev \
            squashfs-tools \
            desktop-file-utils \
            zsync \
            appstream

      - name: Setup Rust
        if: matrix.build_kind == 'tauri'
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.args }}

      - name: Setup Node.js
        if: matrix.build_kind == 'tauri'
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install protoc
        if: matrix.build_kind == 'tauri'
        uses: arduino/setup-protoc@v2
        with:
          repo-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Install Tauri CLI
        if: matrix.build_kind == 'tauri'
        run: npm install -g @tauri-apps/cli@latest

      - name: Setup Go (syftbox)
        if: matrix.build_kind == 'tauri' && runner.os != 'Windows'
        uses: actions/setup-go@v5
        with:
          go-version-file: biovault/syftbox/go.mod
          cache: true
          cache-dependency-path: biovault/syftbox/go.sum

      - name: Cache Rust dependencies
        if: matrix.build_kind == 'tauri'
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            ~/.cargo/bin
            target
            src-tauri/target
          key: ${{ matrix.args }}-cargo-${{ hashFiles('**/Cargo.lock', '**/Cargo.toml') }}
          restore-keys: |
            ${{ matrix.args }}-cargo-

      - name: Create syftbox placeholder
        if: matrix.build_kind == 'tauri'
        shell: bash
        run: |
          mkdir -p src-tauri/resources/syftbox
          touch src-tauri/resources/syftbox/syftbox

      - name: Fetch bundled dependencies
        if: matrix.build_kind == 'tauri' && runner.os != 'Windows'
        shell: bash
        run: |
          chmod +x scripts/fetch-bundled-deps.sh
          ./scripts/fetch-bundled-deps.sh

          if [[ "$RUNNER_OS" == "macOS" ]]; then
            chmod -R u+rw src-tauri/resources/bundled/ || true
            xattr -r -d com.apple.quarantine src-tauri/resources/bundled/ 2>/dev/null || true
          else
            chmod -R u+rw src-tauri/resources/bundled/ || true
          fi

      - name: Build syftbox client
        if: matrix.build_kind == 'tauri' && runner.os != 'Windows'
        run: |
          chmod +x scripts/build-syftbox-prod.sh
          ./scripts/build-syftbox-prod.sh

      - name: Sign bundled binaries (macOS)
        if: runner.os == 'macOS'
        run: |
          echo "Signing all bundled executables for notarization..."
          find src-tauri/resources/bundled -type f -perm +111 | while read -r bin; do
            echo "Signing: $bin"
            codesign --force --options runtime --timestamp --sign "$APPLE_SIGNING_IDENTITY" "$bin" || echo "Warning: failed to sign $bin"
          done
          echo "Done signing bundled binaries"

      - name: Create bundled placeholders (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          New-Item -Path "src-tauri/resources/syftbox" -ItemType Directory -Force
          New-Item -Path "src-tauri/resources/syftbox/syftbox" -ItemType File -Force
          New-Item -Path "src-tauri/resources/bundled/java" -ItemType Directory -Force
          New-Item -Path "src-tauri/resources/bundled/nextflow" -ItemType Directory -Force
          New-Item -Path "src-tauri/resources/bundled/uv" -ItemType Directory -Force
          Set-Content -Path "src-tauri/resources/bundled/README.txt" -Value "Placeholder for bundled dependencies"

      - name: Build app (macOS)
        if: runner.os == 'macOS'
        run: |
          tauri build --target ${{ matrix.args }}

          mkdir -p artifacts
          mv src-tauri/target/${{ matrix.args }}/release/bundle/dmg/*.dmg artifacts/BioVault-Desktop-${{ matrix.args }}.dmg || true
          mv src-tauri/target/${{ matrix.args }}/release/bundle/macos/*.app.tar.gz artifacts/BioVault-Desktop-${{ matrix.args }}.app.tar.gz || true
          mv src-tauri/target/${{ matrix.args }}/release/bundle/macos/*.app.tar.gz.sig artifacts/BioVault-Desktop-${{ matrix.args }}.app.tar.gz.sig || true

      - name: Build app (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          tauri build --target ${{ matrix.args }}

          New-Item -Path artifacts -ItemType Directory -Force
          Move-Item -Path src-tauri\target\${{ matrix.args }}\release\bundle\nsis\*.exe -Destination artifacts\BioVault-Desktop-${{ matrix.args }}.exe -ErrorAction SilentlyContinue
          Move-Item -Path src-tauri\target\${{ matrix.args }}\release\bundle\nsis\*.exe.sig -Destination artifacts\BioVault-Desktop-${{ matrix.args }}.exe.sig -ErrorAction SilentlyContinue

      - name: Setup AppImage tools (Linux)
        if: runner.os == 'Linux' && matrix.build_kind == 'tauri'
        run: |
          ARCH="$(uname -m)"
          if [[ "$ARCH" == "aarch64" ]]; then
            APPIMAGE_ARCH="aarch64"
          else
            APPIMAGE_ARCH="x86_64"
          fi

          # linuxdeploy
          wget -q "https://github.com/tauri-apps/binary-releases/releases/download/linuxdeploy/linuxdeploy-${APPIMAGE_ARCH}.AppImage" -O /tmp/linuxdeploy.AppImage
          chmod +x /tmp/linuxdeploy.AppImage
          # Extract using --appimage-extract (this works without FUSE)
          cd /tmp && APPIMAGE_EXTRACT_AND_RUN=1 ./linuxdeploy.AppImage --appimage-extract || true
          if [ ! -d /tmp/squashfs-root ]; then
            # Fallback: extract squashfs manually
            OFFSET=$(readelf -h /tmp/linuxdeploy.AppImage | grep "Start of section" | awk '{print $NF}')
            unsquashfs -offset $OFFSET -d /tmp/squashfs-root /tmp/linuxdeploy.AppImage || \
            unsquashfs -d /tmp/squashfs-root /tmp/linuxdeploy.AppImage
          fi
          mv /tmp/squashfs-root /tmp/linuxdeploy-extracted
          chmod +x /tmp/linuxdeploy-extracted/AppRun

          # linuxdeploy-plugin-appimage
          wget -q "https://github.com/linuxdeploy/linuxdeploy-plugin-appimage/releases/download/continuous/linuxdeploy-plugin-appimage-${APPIMAGE_ARCH}.AppImage" -O /tmp/plugin.AppImage
          chmod +x /tmp/plugin.AppImage
          cd /tmp && APPIMAGE_EXTRACT_AND_RUN=1 ./plugin.AppImage --appimage-extract || true
          if [ ! -d /tmp/squashfs-root ]; then
            OFFSET=$(readelf -h /tmp/plugin.AppImage | grep "Start of section" | awk '{print $NF}')
            unsquashfs -offset $OFFSET -d /tmp/squashfs-root /tmp/plugin.AppImage || \
            unsquashfs -d /tmp/squashfs-root /tmp/plugin.AppImage
          fi
          mv /tmp/squashfs-root /tmp/plugin-extracted
          chmod +x /tmp/plugin-extracted/AppRun

          echo "AppImage tools extracted successfully"
          ls -la /tmp/linuxdeploy-extracted/
          ls -la /tmp/plugin-extracted/

          {
            echo "LINUXDEPLOY=/tmp/linuxdeploy-extracted/usr/bin/linuxdeploy"
            echo "LINUXDEPLOY_PLUGIN_APPIMAGE=/tmp/plugin-extracted/usr/bin/linuxdeploy-plugin-appimage"
            echo "APPIMAGETOOL=/tmp/plugin-extracted/appimagetool-prefix/usr/bin/appimagetool"
          } >> "$GITHUB_ENV"

      - name: Build app (Linux)
        if: runner.os == 'Linux' && matrix.build_kind == 'tauri'
        run: |
          set -o pipefail
          tauri build --target ${{ matrix.args }} --verbose 2>&1 | tee tauri-linux.log

          mkdir -p artifacts
          mv src-tauri/target/${{ matrix.args }}/release/bundle/deb/*.deb artifacts/BioVault-Desktop-${{ matrix.args }}.deb || true
          mv src-tauri/target/${{ matrix.args }}/release/bundle/appimage/*.AppImage artifacts/BioVault-Desktop-${{ matrix.args }}.AppImage || true

      - name: Dump linuxdeploy logs on failure
        if: failure() && runner.os == 'Linux' && matrix.build_kind == 'tauri'
        run: |
          echo "Searching for linuxdeploy/appimage logs..."
          find src-tauri/target/${{ matrix.args }}/release -maxdepth 5 -type f \( -iname "*linuxdeploy*.log*" -o -iname "*appimage*.log*" \) -print -exec sed -n '1,400p' {} \;
          echo "Dumping tauri-linux.log (if present)..."
          sed -n '1,400p' tauri-linux.log || true

      - name: Build app (Linux arm64 via Docker)
        if: matrix.build_kind == 'docker'
        run: |
          chmod +x docker/linux_arm64/*.sh
          FORCE_BUILDX=1 BUILD_CACHE="--cache-from type=local,src=/tmp/.buildx-cache --cache-to type=local,dest=/tmp/.buildx-cache-new,mode=max" ./docker/linux_arm64/build-image.sh --arm64
          ./docker/linux_arm64/build-appimage.sh --arm64

          mkdir -p artifacts
          sudo chown -R $(id -u):$(id -g) src-tauri/target/${{ matrix.args }}/release/bundle/ || true

          mv src-tauri/target/${{ matrix.args }}/release/bundle/appimage/*.AppImage artifacts/BioVault-Desktop-${{ matrix.args }}.AppImage || echo "No AppImage found"

      - name: Move Docker cache
        if: matrix.build_kind == 'docker'
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache || true

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-${{ matrix.target }}
          path: artifacts/
          if-no-files-found: warn

      - name: Clean up all user keychains
        if: always() && runner.os == 'macOS'
        run: |
          keychains=$(security list-keychains | tr -d '" "')
          echo "$keychains" | while IFS= read -r keychain; do
            if [[ "$keychain" != "/Library/Keychains/System.keychain" && "$keychain" != "/Library/Keychains/SystemRootCertificates.keychain" ]]; then
              echo "Deleting keychain: $keychain"
              security delete-keychain "$keychain"
            fi
          done
