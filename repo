#!/bin/bash
# repo - Workspace dependency management tool
# Version: 1.0.0
# Keep in sync across: biovault-desktop, syftbox-sdk, biovault, biovault-beaver
set -euo pipefail

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
MANIFEST_FILE="${MANIFEST_FILE:-manifest.xml}"
MANIFEST_URL="${MANIFEST_URL:-}"
MANIFEST_BRANCH="${MANIFEST_BRANCH:-}"
REPO_BIN_DIR="${REPO_BIN_DIR:-$ROOT_DIR/.repo-bin}"
REPO_BIN="${REPO_BIN:-$REPO_BIN_DIR/repo}"
MANIFEST_REPO_DIR="${MANIFEST_REPO_DIR:-$ROOT_DIR/.repo-manifest}"
REPO_DEPTH="${REPO_DEPTH:-1}"
MANIFEST_BRANCH_DEFAULT=""

cd "$ROOT_DIR"

usage() {
  cat <<'EOF'
Usage: ./repo [OPTIONS]

Options:
  (none)              Show repo tree with branch/dirty status
  --init [--https]    Initialize repo workspace and sync deps
  sync [branch]       Sync workspace to manifest (repo sync)
                      branch: checkout manifest branches and fast-forward
  sync branch --force Discard local changes, force-sync, and fast-forward manifest branches
  fetch [-j N]        Fetch remotes for all repos and show ahead/behind
  pull [--rebase]     Pull updates for all repos on branches
  ssh                 Rewrite remotes to SSH for all repos
  pin                 Update manifest.xml to current repo SHAs
  main                Checkout main in all repos (no reset)
  switch [-b] <branch> <targets...>
                      Checkout a branch across selected repos
  track <target> <rev>
                      Update manifest revision for a repo (branch/tag/sha)
  <target> <rev>      Shortcut for "track <target> <rev>"
  --status            Show repo tool status
  --branch [name]     Checkout/create branch in all repos
  branch [name]       Create branch in dirty repos only (smart mode)
                      Shows which repos have changes and creates branches
  lint [--force] [--verbose] [targets...]
                      Run lint.sh in dirty repos (parallel, quiet on success)
                      --force runs lint.sh in all repos that have it
                      --verbose prints lint output even on success
  test [--force] [targets...]
                      Run fast unit tests in dirty repos (quiet on success)
                      --force runs tests in all repos with fast tests
  check [targets...]  Run lint and test in parallel, report any failures
  commit -m "msg"     Commit all dirty repos with same message
  push                Push all repos on feature branches
  pr                  Create PRs (sub-repos first, then desktop with links)
  release             Pin manifest to current HEADs and commit
  checkout <rev> <target>
                      Checkout a revision in a repo or all repos
                      target: repo path, repo name, or "all"
                      --reset: discard local changes before checkout
  tools               Check required tools and show install instructions
  --help, -h          Show this help
EOF
}

# Tool definitions: name|check_command|brew|winget|description
REQUIRED_TOOLS=(
  "go|go version|go|GoLang.Go|Go compiler for backend services"
  "node|node --version|node|OpenJS.NodeJS|Node.js runtime for frontend tooling"
  "npm|npm --version|node|OpenJS.NodeJS|Node package manager (comes with Node.js)"
  "rustc|rustc --version|rust|Rustlang.Rust.MSVC|Rust compiler for native code"
  "cargo|cargo --version|rust|Rustlang.Rust.MSVC|Rust package manager (comes with Rust)"
  "python3|python3 --version|python@3|Python.Python.3.12|Python 3 for scripts"
  "uv|uv --version|uv|astral-sh.uv|Fast Python package manager"
  "protoc|protoc --version|protobuf|Google.Protobuf|Protocol Buffers compiler"
)

# Linux-only system libraries required for Tauri: name|pkg-config_name|pacman_pkg|apt_pkg|description
LINUX_SYSTEM_LIBS=(
  "webkit2gtk-4.1|webkit2gtk-4.1|webkit2gtk-4.1|libwebkit2gtk-4.1-dev|WebKit rendering engine for Tauri"
  "javascriptcoregtk-4.1|javascriptcoregtk-4.1|webkit2gtk-4.1|libjavascriptcoregtk-4.1-dev|JavaScript engine for WebKit"
)

repo_tools() {
  echo -e "${CYAN}=== Required Development Tools ===${NC}"
  echo ""

  local missing=()
  local installed=()

  for tool_def in "${REQUIRED_TOOLS[@]}"; do
    IFS='|' read -r name check_cmd brew_pkg winget_pkg description <<< "$tool_def"
    local output
    if output=$(eval "$check_cmd" 2>&1); then
      local version
      version=$(echo "$output" | head -n1)
      installed+=("$name")
      echo -e "  ${GREEN}✓${NC} $name - $version"
    else
      missing+=("$tool_def")
      echo -e "  ${RED}✗${NC} $name - ${YELLOW}not found${NC} ($description)"
    fi
  done

  # Check Linux system libraries (only on Linux)
  local missing_syslibs=()
  if [[ "$OSTYPE" == "linux-gnu"* ]]; then
    echo ""
    echo -e "${CYAN}=== Linux System Libraries ===${NC}"
    echo ""

    for lib_def in "${LINUX_SYSTEM_LIBS[@]}"; do
      IFS='|' read -r name pkg_config_name pacman_pkg apt_pkg description <<< "$lib_def"
      if pkg-config --exists "$pkg_config_name" 2>/dev/null; then
        local version
        version=$(pkg-config --modversion "$pkg_config_name" 2>/dev/null || echo "installed")
        echo -e "  ${GREEN}✓${NC} $name - $version"
      else
        missing_syslibs+=("$lib_def")
        echo -e "  ${RED}✗${NC} $name - ${YELLOW}not found${NC} ($description)"
      fi
    done
  fi

  echo ""

  if [[ ${#missing[@]} -eq 0 && ${#missing_syslibs[@]} -eq 0 ]]; then
    echo -e "${GREEN}✅ All required tools are installed!${NC}"
    return 0
  fi

  local total_missing=$((${#missing[@]} + ${#missing_syslibs[@]}))
  echo -e "${YELLOW}Missing ${total_missing} item(s). Install instructions:${NC}"
  echo ""

  # Detect platform
  local platform="unknown"
  local install_cmds=()

  if [[ "$OSTYPE" == "darwin"* ]]; then
    platform="macos"
  elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
    platform="linux"
  elif [[ "$OSTYPE" == "msys" || "$OSTYPE" == "cygwin" || -n "${WINDIR:-}" ]]; then
    platform="windows"
  fi

  # Collect unique packages
  declare -A brew_pkgs
  declare -A winget_pkgs

  for tool_def in "${missing[@]}"; do
    IFS='|' read -r name check_cmd brew_pkg winget_pkg description <<< "$tool_def"
    brew_pkgs["$brew_pkg"]=1
    winget_pkgs["$winget_pkg"]=1
  done

  case "$platform" in
    macos)
      echo -e "${BLUE}macOS (Homebrew):${NC}"
      if command -v brew >/dev/null 2>&1; then
        local brew_list="${!brew_pkgs[*]}"
        echo -e "  brew install $brew_list"
        echo ""
        echo -ne "${YELLOW}Run this command now? [y/N]: ${NC}"
        read -r confirm
        if [[ "$confirm" == "y" || "$confirm" == "Y" ]]; then
          brew install ${!brew_pkgs[*]}
        fi
      else
        echo "  First install Homebrew: https://brew.sh"
        echo "  Then run: brew install ${!brew_pkgs[*]}"
      fi
      ;;
    linux)
      echo -e "${BLUE}Linux:${NC}"
      # Prefer native package managers on Linux (they handle system libs better)
      if command -v pacman >/dev/null 2>&1; then
        echo -e "  ${GREEN}Arch Linux:${NC}"
        # Map brew packages to pacman
        local pacman_pkgs=""
        local aur_pkgs=""
        for pkg in "${!brew_pkgs[@]}"; do
          case "$pkg" in
            go) pacman_pkgs+=" go" ;;
            node) pacman_pkgs+=" nodejs npm" ;;
            rust) pacman_pkgs+=" rust" ;;
            python@3) pacman_pkgs+=" python" ;;
            protobuf) pacman_pkgs+=" protobuf" ;;
            uv) aur_pkgs+=" uv" ;;
            *) pacman_pkgs+=" $pkg" ;;
          esac
        done
        # Add missing Linux system libraries (deduplicated)
        declare -A syslib_pacman_seen
        for lib_def in "${missing_syslibs[@]}"; do
          IFS='|' read -r _ _ pacman_pkg _ _ <<< "$lib_def"
          if [[ -z "${syslib_pacman_seen[$pacman_pkg]:-}" ]]; then
            pacman_pkgs+=" $pacman_pkg"
            syslib_pacman_seen[$pacman_pkg]=1
          fi
        done
        if [[ -n "$pacman_pkgs" ]]; then
          echo "  sudo pacman -S$pacman_pkgs"
        fi
        if [[ -n "$aur_pkgs" ]]; then
          echo "  yay -S$aur_pkgs  # or: curl -LsSf https://astral.sh/uv/install.sh | sh"
        fi
        echo ""
        echo -ne "${YELLOW}Run this command now? [y/N]: ${NC}"
        read -r confirm
        if [[ "$confirm" == "y" || "$confirm" == "Y" ]]; then
          sudo pacman -S $pacman_pkgs
        fi
      elif command -v apt-get >/dev/null 2>&1; then
        echo -e "  ${GREEN}Debian/Ubuntu:${NC}"
        local apt_pkgs=""
        for pkg in "${!brew_pkgs[@]}"; do
          case "$pkg" in
            go) apt_pkgs+=" golang-go" ;;
            node) apt_pkgs+=" nodejs npm" ;;
            rust) apt_pkgs+=" rustc cargo" ;;
            python@3) apt_pkgs+=" python3" ;;
            protobuf) apt_pkgs+=" protobuf-compiler" ;;
            *) apt_pkgs+=" $pkg" ;;
          esac
        done
        # Add missing Linux system libraries
        for lib_def in "${missing_syslibs[@]}"; do
          IFS='|' read -r _ _ _ apt_pkg _ <<< "$lib_def"
          apt_pkgs+=" $apt_pkg"
        done
        echo "  sudo apt-get install$apt_pkgs"
      else
        echo "  Install Homebrew (works on Linux too): https://brew.sh"
        echo "  Then run: brew install ${!brew_pkgs[*]}"
      fi
      ;;
    windows)
      echo -e "${BLUE}Windows (winget):${NC}"
      for pkg in "${!winget_pkgs[@]}"; do
        echo "  winget install $pkg"
      done
      echo ""
      echo "Or use Chocolatey/Scoop if preferred."
      ;;
    *)
      echo -e "${BLUE}Manual installation required:${NC}"
      for tool_def in "${missing[@]}"; do
        IFS='|' read -r name check_cmd brew_pkg winget_pkg description <<< "$tool_def"
        echo "  - $name: $description"
      done
      ;;
  esac

  echo ""
  return 1
}

REPO_CMD=()
REPO_TARGETS=()

require_repo() {
  if command -v repo >/dev/null 2>&1; then
    REPO_CMD=(repo)
    return
  fi

  if command -v brew >/dev/null 2>&1; then
    local brew_prefix
    brew_prefix="$(brew --prefix repo 2>/dev/null || true)"
    if [[ -n "$brew_prefix" && -x "$brew_prefix/bin/repo" ]]; then
      REPO_CMD=("$brew_prefix/bin/repo")
      return
    fi

    if brew install repo >/dev/null 2>&1; then
      brew_prefix="$(brew --prefix repo 2>/dev/null || true)"
      if [[ -n "$brew_prefix" && -x "$brew_prefix/bin/repo" ]]; then
        REPO_CMD=("$brew_prefix/bin/repo")
        return
      fi
      if command -v repo >/dev/null 2>&1; then
        REPO_CMD=(repo)
        return
      fi
    fi
  fi

  if [[ -x "$REPO_BIN" ]]; then
    REPO_CMD=("$REPO_BIN")
    return
  fi

  mkdir -p "$REPO_BIN_DIR"
  if command -v python >/dev/null 2>&1; then
    python - <<'PY'
import pathlib
import urllib.request

dest = pathlib.Path(".repo-bin/repo")
dest.write_bytes(urllib.request.urlopen("https://storage.googleapis.com/git-repo-downloads/repo").read())
dest.chmod(0o755)
PY
  elif command -v curl >/dev/null 2>&1; then
    curl -s https://storage.googleapis.com/git-repo-downloads/repo -o "$REPO_BIN"
    chmod +x "$REPO_BIN"
  else
    echo "repo tool not found. Install from https://github.com/GerritCodeReview/git-repo" >&2
    exit 1
  fi

  if [[ -x "$REPO_BIN" ]]; then
    REPO_CMD=("$REPO_BIN")
    return
  fi

  echo "repo tool not found and auto-download failed. Install from https://github.com/GerritCodeReview/git-repo" >&2
  exit 1
}

resolve_manifest_url() {
  if [[ -n "$MANIFEST_URL" ]]; then
    echo "$MANIFEST_URL"
    return
  fi

  if git -C "$ROOT_DIR" cat-file -e "HEAD:$MANIFEST_FILE" 2>/dev/null; then
    MANIFEST_BRANCH_DEFAULT="$(git -C "$ROOT_DIR" rev-parse --abbrev-ref HEAD 2>/dev/null || echo main)"
    echo "file://$ROOT_DIR"
    return
  fi

  if [[ ! -f "$MANIFEST_FILE" ]]; then
    echo "Manifest not found: $MANIFEST_FILE" >&2
    exit 1
  fi

  mkdir -p "$MANIFEST_REPO_DIR"
  if [[ ! -d "$MANIFEST_REPO_DIR/.git" ]]; then
    git -C "$MANIFEST_REPO_DIR" init >/dev/null 2>&1
  fi
  git -C "$MANIFEST_REPO_DIR" checkout -B main >/dev/null 2>&1 || true
  git -C "$MANIFEST_REPO_DIR" config user.email "repo@local" >/dev/null 2>&1 || true
  git -C "$MANIFEST_REPO_DIR" config user.name "repo tool" >/dev/null 2>&1 || true

  mkdir -p "$MANIFEST_REPO_DIR/$(dirname "$MANIFEST_FILE")"
  cp "$MANIFEST_FILE" "$MANIFEST_REPO_DIR/$MANIFEST_FILE"
  git -C "$MANIFEST_REPO_DIR" add "$MANIFEST_FILE" >/dev/null 2>&1
  if ! git -C "$MANIFEST_REPO_DIR" diff --cached --quiet -- "$MANIFEST_FILE"; then
    git -C "$MANIFEST_REPO_DIR" commit -m "Update manifest" >/dev/null 2>&1 || true
  fi

  MANIFEST_BRANCH_DEFAULT="$(git -C "$MANIFEST_REPO_DIR" rev-parse --abbrev-ref HEAD 2>/dev/null || echo main)"
  echo "file://$MANIFEST_REPO_DIR"
}

run_repo() {
  PAGER=cat GIT_PAGER=cat LESS=FRX "${REPO_CMD[@]}" "$@"
}

repo_depth_arg() {
  local depth="${REPO_DEPTH:-}"
  if [[ "$depth" =~ ^[0-9]+$ ]] && [[ "$depth" -gt 0 ]]; then
    printf '%s' "$depth"
  fi
}

ensure_syqure_manifest_override() {
  if run_repo manifest -r 2>/dev/null | grep -q 'path="syqure"'; then
    return 0
  fi

  local local_manifest_dir="$ROOT_DIR/.repo/local_manifests"
  local local_manifest_file="$local_manifest_dir/syqure.xml"
  mkdir -p "$local_manifest_dir"
  cat > "$local_manifest_file" <<'EOF'
<?xml version="1.0" encoding="UTF-8"?>
<manifest>
  <project name="madhavajay/syqure" path="syqure" revision="main" />
</manifest>
EOF
  echo -e "${CYAN}→ added local manifest override for syqure${NC}"
}

repo_init() {
  local init_mode="${1:-}"
  if [[ -n "$init_mode" && "$init_mode" != "--https" ]]; then
    echo "Unknown init option: $init_mode" >&2
    exit 1
  fi

  if [[ "$init_mode" == "--https" ]]; then
    repo_init_with_https
    return
  fi

  local url
  url="$(resolve_manifest_url)"
  local branch="${MANIFEST_BRANCH:-$MANIFEST_BRANCH_DEFAULT}"
  local depth
  depth="$(repo_depth_arg)"

  if [[ -n "$branch" ]]; then
    if [[ -n "$depth" ]]; then
      run_repo init -u "$url" -m "$MANIFEST_FILE" -b "$branch" --depth="$depth"
    else
      run_repo init -u "$url" -m "$MANIFEST_FILE" -b "$branch"
    fi
  else
    if [[ -n "$depth" ]]; then
      run_repo init -u "$url" -m "$MANIFEST_FILE" --depth="$depth"
    else
      run_repo init -u "$url" -m "$MANIFEST_FILE"
    fi
  fi

  ensure_syqure_manifest_override
  ensure_origin_remotes
  ensure_syft_crypto_submodule
  ensure_syqure_submodules
}

repo_init_with_https() {
  if [[ ! -f "$MANIFEST_FILE" ]]; then
    echo "Manifest not found: $MANIFEST_FILE" >&2
    exit 1
  fi

  local tmpdir=""
  tmpdir="$(mktemp -d "${TMPDIR:-/tmp}/repo-manifest.XXXXXX")"

  mkdir -p "$tmpdir"
  cp "$MANIFEST_FILE" "$tmpdir/$MANIFEST_FILE"

  if command -v python3 >/dev/null 2>&1; then
    python3 - "$tmpdir/$MANIFEST_FILE" <<'PY'
import sys
import xml.etree.ElementTree as ET
from urllib.parse import urlparse

path = sys.argv[1]
tree = ET.parse(path)
root = tree.getroot()

def to_https(fetch: str) -> str:
    fetch = fetch.strip()
    if fetch.startswith("git@"):
        host, _, rest = fetch[4:].partition(":")
        rest = rest.lstrip("/")
        return f"https://{host}/{rest}".rstrip("/") + "/"
    if fetch.startswith("ssh://git@"):
        rest = fetch[len("ssh://git@") :]
        host, _, path = rest.partition("/")
        path = path.lstrip("/")
        return f"https://{host}/{path}".rstrip("/") + "/"
    if fetch.startswith("https://") or fetch.startswith("http://") or fetch.startswith("git://"):
        parsed = urlparse(fetch)
        host = parsed.netloc
        path = parsed.path.lstrip("/")
        return f"https://{host}/{path}".rstrip("/") + "/"
    return fetch

for remote in root.findall("remote"):
    fetch = remote.get("fetch")
    if fetch:
        remote.set("fetch", to_https(fetch))

tree.write(path, encoding="UTF-8", xml_declaration=True)
PY
  elif command -v python >/dev/null 2>&1; then
    python - "$tmpdir/$MANIFEST_FILE" <<'PY'
import sys
import xml.etree.ElementTree as ET
from urllib.parse import urlparse

path = sys.argv[1]
tree = ET.parse(path)
root = tree.getroot()

def to_https(fetch: str) -> str:
    fetch = fetch.strip()
    if fetch.startswith("git@"):
        host, _, rest = fetch[4:].partition(":")
        rest = rest.lstrip("/")
        return f"https://{host}/{rest}".rstrip("/") + "/"
    if fetch.startswith("ssh://git@"):
        rest = fetch[len("ssh://git@") :]
        host, _, path = rest.partition("/")
        path = path.lstrip("/")
        return f"https://{host}/{path}".rstrip("/") + "/"
    if fetch.startswith("https://") or fetch.startswith("http://") or fetch.startswith("git://"):
        parsed = urlparse(fetch)
        host = parsed.netloc
        path = parsed.path.lstrip("/")
        return f"https://{host}/{path}".rstrip("/") + "/"
    return fetch

for remote in root.findall("remote"):
    fetch = remote.get("fetch")
    if fetch:
        remote.set("fetch", to_https(fetch))

tree.write(path, encoding="UTF-8", xml_declaration=True)
PY
  else
    echo "Python is required for ./repo --init --https" >&2
    exit 1
  fi

  git -C "$tmpdir" init >/dev/null 2>&1
  git -C "$tmpdir" checkout -B main >/dev/null 2>&1 || true
  git -C "$tmpdir" config user.email "repo@local" >/dev/null 2>&1 || true
  git -C "$tmpdir" config user.name "repo tool" >/dev/null 2>&1 || true
  git -C "$tmpdir" add "$MANIFEST_FILE" >/dev/null 2>&1
  git -C "$tmpdir" commit -m "Manifest for HTTPS" >/dev/null 2>&1 || true

  local depth
  depth="$(repo_depth_arg)"
  if [[ -n "$depth" ]]; then
    run_repo init -u "file://$tmpdir" -m "$MANIFEST_FILE" -b main --depth="$depth"
  else
    run_repo init -u "file://$tmpdir" -m "$MANIFEST_FILE" -b main
  fi
  ensure_syqure_manifest_override
  ensure_origin_remotes "$tmpdir/$MANIFEST_FILE"
  ensure_syft_crypto_submodule
  ensure_syqure_submodules
  if [[ -n "$tmpdir" ]]; then
    rm -rf "$tmpdir"
  fi
}

ensure_syft_crypto_submodule() {
  local repo="syft-crypto-core"
  if [[ ! -d "$repo/.git" && ! -f "$repo/.git" ]]; then
    return 0
  fi

  if [[ ! -f "$repo/.gitmodules" ]]; then
    return 0
  fi

  echo -e "${CYAN}→ ${repo} submodules${NC}"
  git -C "$repo" submodule sync --recursive >/dev/null 2>&1 || true
  if ! git -C "$repo" submodule update --init --recursive; then
    echo -e "${RED}✗ ${repo} submodule update failed${NC}" >&2
    return 1
  fi
}

ensure_syqure_submodules() {
  local repo="syqure"
  if [[ ! -d "$repo/.git" && ! -f "$repo/.git" ]]; then
    return 0
  fi

  if [[ ! -f "$repo/.gitmodules" ]]; then
    return 0
  fi

  echo -e "${CYAN}→ ${repo} submodules${NC}"
  git -C "$repo" submodule sync --recursive >/dev/null 2>&1 || true
  if ! git -C "$repo" submodule update --init --recursive --depth 1; then
    echo -e "${YELLOW}WARN: ${repo} shallow submodule update failed; retrying full depth${NC}"
    if ! git -C "$repo" submodule update --init --recursive; then
      echo -e "${RED}✗ ${repo} submodule update failed${NC}" >&2
      return 1
    fi
  fi
}

repo_sync() {
  local mode="${1:-}"
  local force="${2:-}"

  if [[ "$#" -gt 2 ]]; then
    echo "Usage: ./repo sync [branch] [--force]" >&2
    exit 1
  fi

  if [[ -n "$mode" && "$mode" != "branch" && "$mode" != "--branch" ]]; then
    echo "Unknown sync option: $mode" >&2
    exit 1
  fi

  if [[ -n "$force" && "$force" != "--force" ]]; then
    echo "Unknown sync option: $force" >&2
    exit 1
  fi

  ensure_syqure_manifest_override

  if [[ "$mode" == "branch" && "$force" == "--force" ]]; then
    echo -e "${YELLOW}→ Force syncing (discarding local commits/changes)${NC}"
    run_repo forall -c 'git rebase --abort >/dev/null 2>&1 || true; git reset --hard; git clean -fd'
    run_repo sync -d --force-sync
    checkout_manifest_branches
    ensure_syft_crypto_submodule
    ensure_syqure_submodules
    return
  fi

  run_repo sync
  if [[ "$mode" == "branch" || "$mode" == "--branch" ]]; then
    sync_manifest_branches
  fi
  ensure_syft_crypto_submodule
  ensure_syqure_submodules
}

sync_manifest_branches() {
  local failures=0
  local repo
  while IFS= read -r repo; do
    [[ -z "$repo" ]] && continue
    echo -ne "  → $repo: "
    if ! git -C "$repo" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
      echo -e "${RED}missing${NC}"
      failures=$((failures + 1))
      continue
    fi

    if [[ -n $(git -C "$repo" status --porcelain -uno 2>/dev/null || true) ]]; then
      echo -e "${YELLOW}dirty (skipped)${NC}"
      continue
    fi

    local revision
    revision="$(manifest_effective_revision_for "$repo")"
    if [[ -z "$revision" ]]; then
      echo -e "${YELLOW}no revision${NC}"
      continue
    fi

    local remote
    remote="$(resolve_remote_for_repo "$repo" "$repo")"
    if [[ -z "$remote" ]]; then
      echo -e "${YELLOW}no remote${NC}"
      continue
    fi

    git -C "$repo" fetch "$remote" --prune >/dev/null 2>&1 || true

    if git -C "$repo" show-ref --verify --quiet "refs/remotes/$remote/$revision"; then
      if git -C "$repo" show-ref --verify --quiet "refs/heads/$revision"; then
        if ! git -C "$repo" checkout "$revision" >/dev/null 2>&1; then
          echo -e "${RED}failed${NC}"
          failures=$((failures + 1))
          continue
        fi
      else
        if ! git -C "$repo" checkout -b "$revision" --track "$remote/$revision" >/dev/null 2>&1; then
          echo -e "${RED}failed${NC}"
          failures=$((failures + 1))
          continue
        fi
      fi

      git -C "$repo" branch --set-upstream-to "$remote/$revision" "$revision" >/dev/null 2>&1 || true
      local head_before
      head_before=$(git -C "$repo" rev-parse HEAD 2>/dev/null || true)
      if git -C "$repo" merge --ff-only "$remote/$revision" >/dev/null 2>&1; then
        local head_after
        head_after=$(git -C "$repo" rev-parse HEAD 2>/dev/null || true)
        if [[ -n "$head_before" && -n "$head_after" && "$head_before" != "$head_after" ]]; then
          echo -e "${GREEN}updated${NC}"
        else
          echo -e "${GREEN}up-to-date${NC}"
        fi
      else
        echo -e "${YELLOW}diverged${NC}"
      fi
      continue
    fi

    if git -C "$repo" show-ref --verify --quiet "refs/heads/$revision"; then
      if git -C "$repo" checkout "$revision" >/dev/null 2>&1; then
        echo -e "${YELLOW}no remote branch${NC}"
      else
        echo -e "${RED}failed${NC}"
        failures=$((failures + 1))
      fi
      continue
    fi

    if [[ "$revision" =~ ^[0-9a-fA-F]{7,40}$ ]] || git -C "$repo" show-ref --verify --quiet "refs/tags/$revision"; then
      echo -e "${YELLOW}pinned (skipped)${NC}"
      continue
    fi

    echo -e "${YELLOW}missing branch${NC}"
  done < <(manifest_paths)

  if [[ "$failures" -ne 0 ]]; then
    exit 1
  fi
}

checkout_manifest_branches() {
  local failures=0

  while IFS= read -r repo; do
    [[ -z "$repo" ]] && continue

    local revision
    revision="$(manifest_effective_revision_for "$repo")"
    if [[ -z "$revision" ]]; then
      continue
    fi

    if [[ "$revision" =~ ^[0-9a-fA-F]{7,40}$ ]] || git -C "$repo" show-ref --verify --quiet "refs/tags/$revision"; then
      continue
    fi

    if ! git -C "$repo" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
      continue
    fi

    local remote
    remote="$(resolve_remote_for_repo "$repo" "$repo")"

    if [[ -z "$remote" ]]; then
      echo -e "  ${YELLOW}→ ${repo}: no remote found${NC}"
      failures=$((failures + 1))
      continue
    fi

    if ! git -C "$repo" fetch "$remote" --prune >/dev/null 2>&1; then
      echo -e "  ${RED}✗ ${repo}: fetch failed${NC}"
      failures=$((failures + 1))
      continue
    fi

    if git -C "$repo" show-ref --verify --quiet "refs/remotes/$remote/$revision"; then
      if ! git -C "$repo" checkout -B "$revision" "$remote/$revision" >/dev/null 2>&1; then
        echo -e "  ${RED}✗ ${repo}: failed to checkout ${revision}${NC}"
        failures=$((failures + 1))
        continue
      fi
      if ! git -C "$repo" reset --hard "$remote/$revision" >/dev/null 2>&1; then
        echo -e "  ${RED}✗ ${repo}: failed to fast-forward ${revision}${NC}"
        failures=$((failures + 1))
      fi
      continue
    fi

    echo -e "  ${YELLOW}→ ${repo}: branch ${revision} not found on ${remote}${NC}"
    failures=$((failures + 1))
  done < <(manifest_paths)

  if [[ "$failures" -ne 0 ]]; then
    return 1
  fi
}

repo_fetch() {
  local jobs=0
  if [[ "${1:-}" == "-j" ]]; then
    jobs="${2:-0}"
  fi
  if [[ "$jobs" -lt 0 ]]; then
    jobs=0
  fi

  local -a repos=()
  while IFS= read -r repo; do
    [[ -z "$repo" ]] && continue
    repos+=("$repo")
  done < <(manifest_paths)

  fetch_one() {
    local repo="$1"
    [[ -z "$repo" ]] && return 0
    echo -ne "  → $repo: "
    if ! git -C "$repo" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
      echo -e "${RED}missing${NC}"
      return 1
    fi

    local branch
    branch=$(git -C "$repo" rev-parse --abbrev-ref HEAD 2>/dev/null || echo "HEAD")
    local head_sha
    head_sha=$(git -C "$repo" rev-parse HEAD 2>/dev/null || echo "")

    local remote
    remote="$(resolve_remote_for_repo "$repo" "$repo")"
    if [[ -z "$remote" ]]; then
      echo -e "${YELLOW}no remote${NC}"
      return 0
    fi

    local fetch_output=""
    fetch_output=$(git -C "$repo" fetch "$remote" --prune 2>&1) || {
      echo -e "${RED}fetch failed${NC}"
      if [[ -n "$fetch_output" ]]; then
        while IFS= read -r line; do
          [[ -z "$line" ]] && continue
          echo "    $line"
          break
        done <<< "$fetch_output"
      fi
      return 1
    }

    if [[ "$branch" == "HEAD" ]]; then
      local manifest_rev
      manifest_rev="$(manifest_revision_for "$repo")"
      if [[ -n "$manifest_rev" && -n "$head_sha" ]]; then
        if [[ "$manifest_rev" =~ ^[0-9a-fA-F]{7,40}$ ]]; then
          if [[ "${head_sha}" == "${manifest_rev}"* ]]; then
            echo -e "${GREEN}pinned${NC}"
            return 0
          fi
        else
          local resolved
          resolved=$(git -C "$repo" rev-parse --verify -q "${manifest_rev}^{commit}" 2>/dev/null || true)
          if [[ -n "$resolved" && "$resolved" == "$head_sha" ]]; then
            echo -e "${GREEN}pinned${NC}"
            return 0
          fi
        fi
      fi
      echo -e "${YELLOW}detached${NC}"
      return 0
    fi

    local upstream_ref
    upstream_ref="$(resolve_upstream_ref "$repo" "$repo" "$branch")"
    if [[ -z "$upstream_ref" ]]; then
      echo -e "${YELLOW}no upstream${NC}"
      return 0
    fi

    local counts
    counts=$(git -C "$repo" rev-list --left-right --count "$branch...$upstream_ref" 2>/dev/null || echo "0 0")
    set -- $counts
    local ahead="${1:-0}"
    local behind="${2:-0}"

    if [[ "$ahead" == "0" && "$behind" == "0" ]]; then
      echo -e "${GREEN}up-to-date${NC}"
    elif [[ "$behind" != "0" && "$ahead" != "0" ]]; then
      echo -e "${YELLOW}ahead:${ahead} behind:${behind}${NC}"
    elif [[ "$behind" != "0" ]]; then
      echo -e "${YELLOW}behind:${behind}${NC}"
    else
      echo -e "${YELLOW}ahead:${ahead}${NC}"
    fi
    return 0
  }

  local tmpdir=""
  tmpdir="$(mktemp -d "${TMPDIR:-/tmp}/repo-fetch.XXXXXX")"

  local failures=0
  local -a pids=()
  local -a outputs=()

  local idx=0
  for repo in "${repos[@]}"; do
    local outfile
    outfile="$tmpdir/$(printf '%05d' "$idx")"
    outputs+=("$outfile")
    idx=$((idx + 1))

    if [[ "$jobs" -eq 1 ]]; then
      if fetch_one "$repo" >"$outfile" 2>&1; then
        echo 0 >"${outfile}.status"
      else
        echo 1 >"${outfile}.status"
      fi
      continue
    fi

    if fetch_one "$repo" >"$outfile" 2>&1; then
      echo 0 >"${outfile}.status"
    else
      echo 1 >"${outfile}.status"
    fi &
    pids+=("$!")

    if [[ "$jobs" -gt 0 && "${#pids[@]}" -ge "$jobs" ]]; then
      local pid="${pids[0]}"
      wait "$pid" || true
      pids=("${pids[@]:1}")
    fi
  done

  for pid in "${pids[@]:-}"; do
    wait "$pid" || true
  done

  for outfile in "${outputs[@]}"; do
    if [[ -f "$outfile" ]]; then
      cat "$outfile"
    fi
    if [[ -f "${outfile}.status" ]]; then
      if [[ "$(cat "${outfile}.status")" != "0" ]]; then
        failures=$((failures + 1))
      fi
    fi
  done

  if [[ -n "$tmpdir" ]]; then
    rm -rf "$tmpdir"
  fi

  if [[ "$failures" -ne 0 ]]; then
    exit 1
  fi
}

repo_pull() {
  local rebase=0
  if [[ "${1:-}" == "--rebase" ]]; then
    rebase=1
  fi

  local failures=0
  while IFS= read -r repo; do
    [[ -z "$repo" ]] && continue
    echo -ne "  → $repo: "
    if ! git -C "$repo" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
      echo -e "${RED}missing${NC}"
      failures=$((failures + 1))
      continue
    fi

    if [[ -n $(git -C "$repo" status --porcelain -uno 2>/dev/null || true) ]]; then
      echo -e "${YELLOW}dirty (skipped)${NC}"
      continue
    fi

    local branch
    branch=$(git -C "$repo" rev-parse --abbrev-ref HEAD 2>/dev/null || echo "HEAD")
    if [[ "$branch" == "HEAD" ]]; then
      echo -e "${YELLOW}detached (skipped)${NC}"
      continue
    fi

    local upstream_ref
    upstream_ref="$(resolve_upstream_ref "$repo" "$repo" "$branch")"
    if [[ -z "$upstream_ref" ]]; then
      echo -e "${YELLOW}no upstream (skipped)${NC}"
      continue
    fi

    local remote="${upstream_ref%%/*}"
    local upstream_branch="${upstream_ref#*/}"

    if [[ "$rebase" -eq 1 ]]; then
      if git -C "$repo" pull --rebase "$remote" "$upstream_branch" >/dev/null 2>&1; then
        echo -e "${GREEN}updated${NC}"
      else
        echo -e "${RED}failed${NC}"
        failures=$((failures + 1))
      fi
    else
      if git -C "$repo" pull "$remote" "$upstream_branch" >/dev/null 2>&1; then
        echo -e "${GREEN}updated${NC}"
      else
        echo -e "${RED}failed${NC}"
        failures=$((failures + 1))
      fi
    fi
  done < <(manifest_paths)

  if [[ "$failures" -ne 0 ]]; then
    exit 1
  fi
}

repo_ssh() {
  local failures=0
  while IFS= read -r repo; do
    [[ -z "$repo" ]] && continue
    echo -ne "  → $repo: "
    if ! git -C "$repo" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
      echo -e "${RED}missing${NC}"
      failures=$((failures + 1))
      continue
    fi

    local remote
    remote="$(resolve_remote_for_repo "$repo" "$repo")"
    if [[ -z "$remote" ]]; then
      echo -e "${YELLOW}no remote${NC}"
      continue
    fi

    local desired
    desired="$(desired_ssh_url_for "$repo")"
    if [[ -z "$desired" ]]; then
      echo -e "${YELLOW}no manifest remote${NC}"
      continue
    fi

    local current
    current=$(git -C "$repo" remote get-url "$remote" 2>/dev/null || true)
    if [[ "$current" == "git@"* || "$current" == "ssh://git@"* ]]; then
      echo -e "${GREEN}ok${NC}"
      continue
    fi

    if git -C "$repo" remote set-url "$remote" "$desired" >/dev/null 2>&1; then
      echo -e "${GREEN}updated${NC}"
    else
      echo -e "${RED}failed${NC}"
      failures=$((failures + 1))
    fi
  done < <(manifest_paths)

  if [[ "$failures" -ne 0 ]]; then
    exit 1
  fi
}

repo_pin() {
  run_repo manifest -r -o "$MANIFEST_FILE"
  normalize_manifest "$MANIFEST_FILE"
  echo "Updated $MANIFEST_FILE"
}

normalize_manifest() {
  local path="$1"
  if command -v python3 >/dev/null 2>&1; then
    python3 - "$path" <<'PY'
import sys
import xml.etree.ElementTree as ET

path = sys.argv[1]
tree = ET.parse(path)
root = tree.getroot()

projects = [child for child in list(root) if child.tag == "project"]
others = [child for child in list(root) if child.tag != "project"]

for proj in projects:
    proj.attrib.pop("upstream", None)
    proj.attrib.pop("dest-branch", None)

def sort_key(elem):
    return (elem.get("path") or "", elem.get("name") or "")

projects.sort(key=sort_key)
root[:] = others + projects

def indent(elem, level=0):
    i = "\n" + level * "  "
    if len(elem):
        if not elem.text or not elem.text.strip():
            elem.text = i + "  "
        for child in elem:
            indent(child, level + 1)
        if not elem.tail or not elem.tail.strip():
            elem.tail = i
    else:
        if level and (not elem.tail or not elem.tail.strip()):
            elem.tail = i

indent(root)
tree.write(path, encoding="UTF-8", xml_declaration=True)
PY
  elif command -v python >/dev/null 2>&1; then
    python - "$path" <<'PY'
import sys
import xml.etree.ElementTree as ET

path = sys.argv[1]
tree = ET.parse(path)
root = tree.getroot()

projects = [child for child in list(root) if child.tag == "project"]
others = [child for child in list(root) if child.tag != "project"]

for proj in projects:
    proj.attrib.pop("upstream", None)
    proj.attrib.pop("dest-branch", None)

def sort_key(elem):
    return (elem.get("path") or "", elem.get("name") or "")

projects.sort(key=sort_key)
root[:] = others + projects

def indent(elem, level=0):
    i = "\n" + level * "  "
    if len(elem):
        if not elem.text or not elem.text.strip():
            elem.text = i + "  "
        for child in elem:
            indent(child, level + 1)
        if not elem.tail or not elem.tail.strip():
            elem.tail = i
    else:
        if level and (not elem.tail or not elem.tail.strip()):
            elem.tail = i

indent(root)
tree.write(path, encoding="UTF-8", xml_declaration=True)
PY
  fi
}

manifest_set_revision() {
  local target="$1"
  local revision="$2"

  if [[ -z "$target" || -z "$revision" ]]; then
    echo "Usage: ./repo track <target> <rev>" >&2
    exit 1
  fi

  if [[ "$target" == "all" ]]; then
    echo "track does not support target 'all'" >&2
    exit 1
  fi

  local repo_path
  repo_path="$(resolve_checkout_targets "$target")"

  if command -v python3 >/dev/null 2>&1; then
    python3 - "$MANIFEST_FILE" "$repo_path" "$revision" <<'PY'
import sys
import xml.etree.ElementTree as ET

path, repo_path, revision = sys.argv[1:4]
tree = ET.parse(path)
root = tree.getroot()

matches = []
for proj in root.findall("project"):
    proj_path = proj.get("path") or proj.get("name")
    if proj_path == repo_path:
        matches.append(proj)

if not matches:
    raise SystemExit(f"Project not found in manifest: {repo_path}")
if len(matches) > 1:
    raise SystemExit(f"Project path is not unique in manifest: {repo_path}")

proj = matches[0]
proj.set("revision", revision)
proj.attrib.pop("upstream", None)
proj.attrib.pop("dest-branch", None)

tree.write(path, encoding="UTF-8", xml_declaration=True)
PY
  elif command -v python >/dev/null 2>&1; then
    python - "$MANIFEST_FILE" "$repo_path" "$revision" <<'PY'
import sys
import xml.etree.ElementTree as ET

path, repo_path, revision = sys.argv[1:4]
tree = ET.parse(path)
root = tree.getroot()

matches = []
for proj in root.findall("project"):
    proj_path = proj.get("path") or proj.get("name")
    if proj_path == repo_path:
        matches.append(proj)

if not matches:
    raise SystemExit(f"Project not found in manifest: {repo_path}")
if len(matches) > 1:
    raise SystemExit(f"Project path is not unique in manifest: {repo_path}")

proj = matches[0]
proj.set("revision", revision)
proj.attrib.pop("upstream", None)
proj.attrib.pop("dest-branch", None)

tree.write(path, encoding="UTF-8", xml_declaration=True)
PY
  else
    echo "Python is required to update $MANIFEST_FILE" >&2
    exit 1
  fi

  normalize_manifest "$MANIFEST_FILE"
  echo "Updated $MANIFEST_FILE"
}

require_repo_workspace() {
  if [[ ! -d "$ROOT_DIR/.repo" ]]; then
    echo "repo workspace not initialized. Run: ./repo --init" >&2
    exit 1
  fi
}

manifest_revision_for() {
  local target="$1"
  if [[ -z "$target" || ! -f "$MANIFEST_FILE" ]]; then
    return 0
  fi

  if command -v python3 >/dev/null 2>&1; then
    python3 - "$MANIFEST_FILE" "$target" <<'PY'
import sys
import xml.etree.ElementTree as ET

manifest, target = sys.argv[1:3]
tree = ET.parse(manifest)
for proj in tree.findall("project"):
    path = proj.get("path") or proj.get("name")
    if path == target:
        revision = proj.get("revision") or ""
        if revision:
            print(revision)
        break
PY
    return
  fi

  if command -v python >/dev/null 2>&1; then
    python - "$MANIFEST_FILE" "$target" <<'PY'
import sys
import xml.etree.ElementTree as ET

manifest, target = sys.argv[1:3]
tree = ET.parse(manifest)
for proj in tree.findall("project"):
    path = proj.get("path") or proj.get("name")
    if path == target:
        revision = proj.get("revision") or ""
        if revision:
            print(revision)
        break
PY
    return
  fi

  awk -v target="$target" '
    /<project / {
      path=""
      rev=""
      if (match($0, /path="[^"]+"/)) {
        path=substr($0, RSTART+6, RLENGTH-7)
      } else if (match($0, /name="[^"]+"/)) {
        path=substr($0, RSTART+6, RLENGTH-7)
      }
      if (match($0, /revision="[^"]+"/)) {
        rev=substr($0, RSTART+10, RLENGTH-11)
      }
      if (path == target && rev != "") {
        print rev
        exit 0
      }
    }
  ' "$MANIFEST_FILE"
}

manifest_default_revision() {
  if [[ ! -f "$MANIFEST_FILE" ]]; then
    return 0
  fi

  if command -v python3 >/dev/null 2>&1; then
    python3 - "$MANIFEST_FILE" <<'PY'
import sys
import xml.etree.ElementTree as ET

manifest = sys.argv[1]
tree = ET.parse(manifest)
default = tree.getroot().find("default")
if default is not None:
    revision = default.get("revision") or ""
    if revision:
        print(revision)
PY
    return
  fi

  if command -v python >/dev/null 2>&1; then
    python - "$MANIFEST_FILE" <<'PY'
import sys
import xml.etree.ElementTree as ET

manifest = sys.argv[1]
tree = ET.parse(manifest)
default = tree.getroot().find("default")
if default is not None:
    revision = default.get("revision") or ""
    if revision:
        print(revision)
PY
    return
  fi

  awk -F'"' '/<default / { for (i = 1; i <= NF; i++) { if ($i == "revision") { print $(i + 1); exit } } }' "$MANIFEST_FILE"
}

manifest_effective_revision_for() {
  local target="$1"
  local revision=""
  revision="$(manifest_revision_for "$target")"
  if [[ -n "$revision" ]]; then
    echo "$revision"
    return
  fi
  manifest_default_revision
}

manifest_remote_for() {
  local target="$1"
  if [[ -z "$target" || ! -f "$MANIFEST_FILE" ]]; then
    return 0
  fi

  if command -v python3 >/dev/null 2>&1; then
    python3 - "$MANIFEST_FILE" "$target" <<'PY'
import sys
import xml.etree.ElementTree as ET

manifest, target = sys.argv[1:3]
tree = ET.parse(manifest)
root = tree.getroot()
default = root.find("default")
default_remote = ""
if default is not None:
    default_remote = default.get("remote") or ""

for proj in root.findall("project"):
    path = proj.get("path") or proj.get("name")
    if path == target:
        remote = proj.get("remote") or default_remote
        if remote:
            print(remote)
        break
PY
    return
  fi

  if command -v python >/dev/null 2>&1; then
    python - "$MANIFEST_FILE" "$target" <<'PY'
import sys
import xml.etree.ElementTree as ET

manifest, target = sys.argv[1:3]
tree = ET.parse(manifest)
root = tree.getroot()
default = root.find("default")
default_remote = ""
if default is not None:
    default_remote = default.get("remote") or ""

for proj in root.findall("project"):
    path = proj.get("path") or proj.get("name")
    if path == target:
        remote = proj.get("remote") or default_remote
        if remote:
            print(remote)
        break
PY
    return
  fi

  local default_remote=""
  default_remote=$(awk -F'"' '/<default / { for (i = 1; i <= NF; i++) { if ($i == "remote") { print $(i + 1); exit } } }' "$MANIFEST_FILE")
  awk -v target="$target" -v def="$default_remote" '
    /<project / {
      path=""
      remote=""
      if (match($0, /path="[^"]+"/)) {
        path=substr($0, RSTART+6, RLENGTH-7)
      } else if (match($0, /name="[^"]+"/)) {
        path=substr($0, RSTART+6, RLENGTH-7)
      }
      if (path != target) {
        next
      }
      if (match($0, /remote="[^"]+"/)) {
        remote=substr($0, RSTART+8, RLENGTH-9)
      } else {
        remote=def
      }
      if (remote != "") {
        print remote
      }
      exit 0
    }
  ' "$MANIFEST_FILE"
}

manifest_project_name_for() {
  local target="$1"
  if [[ -z "$target" || ! -f "$MANIFEST_FILE" ]]; then
    return 0
  fi

  if command -v python3 >/dev/null 2>&1; then
    python3 - "$MANIFEST_FILE" "$target" <<'PY'
import sys
import xml.etree.ElementTree as ET

manifest, target = sys.argv[1:3]
tree = ET.parse(manifest)
for proj in tree.findall("project"):
    path = proj.get("path") or proj.get("name")
    if path == target:
        name = proj.get("name") or ""
        if name:
            print(name)
        break
PY
    return
  fi

  if command -v python >/dev/null 2>&1; then
    python - "$MANIFEST_FILE" "$target" <<'PY'
import sys
import xml.etree.ElementTree as ET

manifest, target = sys.argv[1:3]
tree = ET.parse(manifest)
for proj in tree.findall("project"):
    path = proj.get("path") or proj.get("name")
    if path == target:
        name = proj.get("name") or ""
        if name:
            print(name)
        break
PY
    return
  fi

  awk -v target="$target" '
    /<project / {
      path=""
      name=""
      if (match($0, /path="[^"]+"/)) {
        path=substr($0, RSTART+6, RLENGTH-7)
      } else if (match($0, /name="[^"]+"/)) {
        path=substr($0, RSTART+6, RLENGTH-7)
      }
      if (path != target) {
        next
      }
      if (match($0, /name="[^"]+"/)) {
        name=substr($0, RSTART+6, RLENGTH-7)
      }
      if (name != "") {
        print name
      }
      exit 0
    }
  ' "$MANIFEST_FILE"
}

manifest_fetch_for() {
  local remote_name="$1"
  if [[ -z "$remote_name" || ! -f "$MANIFEST_FILE" ]]; then
    return 0
  fi

  if command -v python3 >/dev/null 2>&1; then
    python3 - "$MANIFEST_FILE" "$remote_name" <<'PY'
import sys
import xml.etree.ElementTree as ET

manifest, remote_name = sys.argv[1:3]
tree = ET.parse(manifest)
root = tree.getroot()
for remote in root.findall("remote"):
    if (remote.get("name") or "") == remote_name:
        fetch = remote.get("fetch") or ""
        if fetch:
            print(fetch)
        break
PY
    return
  fi

  if command -v python >/dev/null 2>&1; then
    python - "$MANIFEST_FILE" "$remote_name" <<'PY'
import sys
import xml.etree.ElementTree as ET

manifest, remote_name = sys.argv[1:3]
tree = ET.parse(manifest)
root = tree.getroot()
for remote in root.findall("remote"):
    if (remote.get("name") or "") == remote_name:
        fetch = remote.get("fetch") or ""
        if fetch:
            print(fetch)
        break
PY
    return
  fi

  awk -v target="$remote_name" -F'"' '
    /<remote / {
      name=""
      fetch=""
      for (i = 1; i <= NF; i++) {
        if ($i == "name") {
          name=$(i + 1)
        } else if ($i == "fetch") {
          fetch=$(i + 1)
        }
      }
      if (name == target && fetch != "") {
        print fetch
        exit 0
      }
    }
  ' "$MANIFEST_FILE"
}

desired_ssh_url_for() {
  local path="$1"
  local remote_name
  remote_name="$(manifest_remote_for "$path")"
  local fetch
  fetch="$(manifest_fetch_for "$remote_name")"
  local project
  project="$(manifest_project_name_for "$path")"

  if [[ -z "$fetch" || -z "$project" ]]; then
    return 0
  fi

  local host=""
  case "$fetch" in
    ssh://git@*/*)
      host="${fetch#ssh://git@}"
      host="${host%%/*}"
      ;;
    http://*/*|https://*/*)
      host="${fetch#*://}"
      host="${host%%/*}"
      ;;
    git@*:*)
      host="${fetch#git@}"
      host="${host%%:*}"
      ;;
  esac

  if [[ -z "$host" ]]; then
    return 0
  fi

  echo "git@${host}:${project}.git"
}

ensure_origin_remotes() {
  local manifest_path="${1:-$MANIFEST_FILE}"
  if [[ -z "$manifest_path" || ! -f "$manifest_path" ]]; then
    return 0
  fi

  local MANIFEST_FILE="$manifest_path"
  local path
  while IFS= read -r path; do
    [[ -z "$path" ]] && continue
    if [[ "$path" == "." ]]; then
      continue
    fi
    if [[ ! -d "$path/.git" && ! -f "$path/.git" ]]; then
      continue
    fi
    if git -C "$path" remote get-url origin >/dev/null 2>&1; then
      continue
    fi

    local remote_name
    remote_name="$(manifest_remote_for "$path")"
    local fetch
    fetch="$(manifest_fetch_for "$remote_name")"
    local project
    project="$(manifest_project_name_for "$path")"
    if [[ -z "$fetch" || -z "$project" ]]; then
      continue
    fi

    local url=""
    case "$fetch" in
      */|*:)
        url="${fetch}${project}"
        ;;
      *)
        url="${fetch}/${project}"
        ;;
    esac

    git -C "$path" remote add origin "$url" >/dev/null 2>&1 || true
  done < <(manifest_paths)
}

resolve_remote_for_repo() {
  local repo="$1"
  local path="$2"
  local upstream

  upstream=$(git -C "$repo" rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null || true)
  if [[ -n "$upstream" && "$upstream" != "@{u}" ]]; then
    echo "${upstream%%/*}"
    return
  fi

  local remotes
  remotes=$(git -C "$repo" remote 2>/dev/null || true)
  if [[ -z "$remotes" ]]; then
    return
  fi

  local remote_count
  remote_count=$(printf '%s\n' "$remotes" | awk 'END { print NR }')
  if [[ "$remote_count" -eq 1 ]]; then
    echo "$remotes"
    return
  fi

  local manifest_remote
  manifest_remote="$(manifest_remote_for "$path")"
  if [[ -n "$manifest_remote" ]]; then
    if printf '%s\n' "$remotes" | awk -v target="$manifest_remote" '$0 == target { found=1 } END { exit !found }'; then
      echo "$manifest_remote"
      return
    fi
  fi

  printf '%s\n' "$remotes" | head -n1
}

resolve_upstream_ref() {
  local repo="$1"
  local path="$2"
  local branch="$3"
  local upstream

  upstream=$(git -C "$repo" rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null || true)
  if [[ -n "$upstream" && "$upstream" != "@{u}" ]]; then
    echo "$upstream"
    return
  fi

  local remote
  remote="$(resolve_remote_for_repo "$repo" "$path")"
  if [[ -n "$remote" && -n "$branch" ]]; then
    if git -C "$repo" show-ref --verify --quiet "refs/remotes/$remote/$branch"; then
      echo "$remote/$branch"
      return
    fi
  fi
}

manifest_paths() {
  if [[ ! -f "$MANIFEST_FILE" ]]; then
    echo "Manifest not found: $MANIFEST_FILE" >&2
    exit 1
  fi

  if command -v python3 >/dev/null 2>&1; then
    python3 - "$MANIFEST_FILE" <<'PY'
import sys
import xml.etree.ElementTree as ET

manifest = sys.argv[1]
tree = ET.parse(manifest)
for proj in tree.findall("project"):
    path = proj.get("path") or proj.get("name")
    if path:
        print(path)
PY
    return
  elif command -v python >/dev/null 2>&1; then
    python - "$MANIFEST_FILE" <<'PY'
import sys
import xml.etree.ElementTree as ET

manifest = sys.argv[1]
tree = ET.parse(manifest)
for proj in tree.findall("project"):
    path = proj.get("path") or proj.get("name")
    if path:
        print(path)
PY
    return
  fi

  awk -F'path="' '/<project / { if (NF > 1) { split($2, parts, "\""); if (parts[1] != "") print parts[1]; } }' "$MANIFEST_FILE" \
    | awk 'NF'
}

add_target() {
  local target="$1"
  local existing
  for existing in "${REPO_TARGETS[@]:-}"; do
    if [[ "$existing" == "$target" ]]; then
      return
    fi
  done
  REPO_TARGETS+=("$target")
}

resolve_targets() {
  REPO_TARGETS=()
  if [[ "$#" -eq 0 ]]; then
    echo "Missing targets. Use 'all' or list repo names/paths." >&2
    exit 1
  fi

  local arg
  while [[ "$#" -gt 0 ]]; do
    arg="$1"
    shift
    case "$arg" in
      self)
        add_target "$ROOT_DIR"
        ;;
      all)
        while IFS= read -r path; do
          [[ -z "$path" ]] && continue
          add_target "$path"
        done < <(manifest_paths)
        ;;
      *)
        while IFS= read -r path; do
          [[ -z "$path" ]] && continue
          add_target "$path"
        done < <(resolve_checkout_targets "$arg")
        ;;
    esac
  done

  if [[ "${#REPO_TARGETS[@]}" -eq 0 ]]; then
    echo "No matching targets found." >&2
    exit 1
  fi

  printf '%s\n' "${REPO_TARGETS[@]}"
}

print_repo() {
  local path="$1"
  local indent="$2"
  local prefix="$3"

  if [[ ! -d "$path/.git" && ! -f "$path/.git" ]]; then
    echo -e "${indent}${prefix}${CYAN}${path##*/}/${NC} ${RED}[missing]${NC}"
    return
  fi

  if ! git -C "$path" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    echo -e "${indent}${prefix}${CYAN}${path##*/}/${NC} ${RED}[broken]${NC}"
    return
  fi

  local branch
  branch=$(git -C "$path" rev-parse --abbrev-ref HEAD 2>/dev/null || echo "HEAD")
  local head_sha
  head_sha=$(git -C "$path" rev-parse HEAD 2>/dev/null || echo "")
  local dirty=""
  local dirty_color=""

  if [[ -n $(git -C "$path" status --porcelain -uno 2>/dev/null || true) ]]; then
    dirty=" [dirty]"
    dirty_color="${RED}"
  else
    dirty_color="${GREEN}"
  fi

  local manifest_note=""
  local manifest_rev
  manifest_rev="$(manifest_revision_for "$path")"
  local manifest_match=""
  if [[ -n "$manifest_rev" && -n "$head_sha" ]]; then
    manifest_match=0
    if [[ "$manifest_rev" =~ ^[0-9a-fA-F]{7,40}$ ]]; then
      if [[ "${head_sha}" == "${manifest_rev}"* ]]; then
        manifest_match=1
      fi
    else
      if [[ "$branch" != "HEAD" && "$branch" == "$manifest_rev" ]]; then
        manifest_match=1
      else
        local resolved
        resolved=$(git -C "$path" rev-parse --verify -q "${manifest_rev}^{commit}" 2>/dev/null || true)
        if [[ -n "$resolved" && "$resolved" == "$head_sha" ]]; then
          manifest_match=1
        fi
      fi
    fi

    if [[ "$manifest_match" -eq 0 ]]; then
      local manifest_display="$manifest_rev"
      if [[ "$manifest_rev" =~ ^[0-9a-fA-F]{7,40}$ ]]; then
        manifest_display="${manifest_rev:0:7}"
      fi
      manifest_note=" ${BLUE}[manifest:${manifest_display}]${NC}"
    fi
  fi

  local branch_display=""
  if [[ "$branch" == "HEAD" ]]; then
    local tag
    local detached_color="${YELLOW}"
    if [[ "$manifest_match" == "1" ]]; then
      detached_color="${GREEN}"
    fi
    tag=$(git -C "$path" describe --tags --exact-match 2>/dev/null || true)
    if [[ -n "$tag" ]]; then
      branch_display="${detached_color}($tag)${NC}"
    else
      local short_sha
      short_sha=$(git -C "$path" rev-parse --short HEAD 2>/dev/null || echo "unknown")
      branch_display="${detached_color}(detached: $short_sha)${NC}"
    fi
  else
    branch_display="${BLUE}[$branch]${NC}"
  fi

  echo -e "${indent}${prefix}${CYAN}${path##*/}/${NC} ${branch_display}${dirty_color}${dirty}${NC}${manifest_note}"
}

show_tree() {
  local root_branch
  root_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
  local root_dirty=""
  if [[ -n $(git status --porcelain -uno 2>/dev/null || true) ]]; then
    root_dirty=" ${RED}[dirty]${NC}"
  fi
  echo -e "${CYAN}$(basename "$(pwd)")/${NC} ${BLUE}[$root_branch]${NC}${root_dirty}"

  local python_cmd=""
  if command -v python3 >/dev/null 2>&1; then
    python_cmd="python3"
  elif command -v python >/dev/null 2>&1; then
    python_cmd="python"
  fi

  local print_flat=false
  if [[ -z "$python_cmd" ]]; then
    print_flat=true
  fi

  local tree_lines
  if [[ "$print_flat" == false ]]; then
    if ! tree_lines="$("$python_cmd" - "$MANIFEST_FILE" <<'PY'
import sys
import xml.etree.ElementTree as ET

manifest = sys.argv[1]
tree = ET.parse(manifest)
paths = []
for proj in tree.findall("project"):
    path = proj.get("path") or proj.get("name")
    if path:
        paths.append(path)

path_set = set(paths)
sep = "\x1f"

def parent_of(path: str):
    parts = path.split("/")
    for i in range(len(parts) - 1, 0, -1):
        candidate = "/".join(parts[:i])
        if candidate in path_set:
            return candidate
    return None

children = {}
for path in paths:
    parent = parent_of(path)
    children.setdefault(parent, []).append(path)

def walk(parent, indent=""):
    kids = sorted(children.get(parent, []))
    for idx, child in enumerate(kids):
        last = idx == len(kids) - 1
        prefix = "└── " if last else "├── "
        print(f"{indent}{sep}{prefix}{sep}{child}")
        walk(child, indent + ("    " if last else "│   "))

walk(None)
PY
    )"; then
      print_flat=true
    fi
  fi

  if [[ "$print_flat" == true ]]; then
    manifest_paths | sort | while IFS= read -r path; do
      print_repo "$path" "" "- "
    done
  else
    while IFS=$'\x1f' read -r indent prefix path; do
      [[ -z "$path" ]] && continue
      print_repo "$path" "$indent" "$prefix"
    done <<< "$tree_lines"
  fi

  echo ""
  echo -e "${GREEN}Legend:${NC}"
  echo -e "  ${BLUE}[branch]${NC}     - on branch"
  echo -e "  ${YELLOW}(tag)${NC}        - detached at tag"
  echo -e "  ${YELLOW}(detached)${NC}   - detached HEAD"
  echo -e "  ${RED}[dirty]${NC}      - uncommitted changes"
  echo -e "  ${BLUE}[manifest:x]${NC} - differs from manifest revision"
  echo -e "  ${RED}[missing]${NC}    - repo not checked out"
}

resolve_checkout_targets() {
  local target="$1"
  local -a matches
  matches=()

  if [[ "$target" == "all" ]]; then
    manifest_paths
    return
  fi

  while IFS= read -r path; do
    [[ -z "$path" ]] && continue
    if [[ "$path" == "$target" ]]; then
      matches+=("$path")
    fi
  done < <(manifest_paths)

  if [[ "${#matches[@]}" -eq 0 ]]; then
    while IFS= read -r path; do
      [[ -z "$path" ]] && continue
      if [[ "$(basename "$path")" == "$target" ]]; then
        matches+=("$path")
      fi
    done < <(manifest_paths)
  fi

  if [[ "${#matches[@]}" -eq 0 ]]; then
    echo "Unknown repo target: $target" >&2
    exit 1
  fi
  if [[ "${#matches[@]}" -gt 1 ]]; then
    echo "Ambiguous repo name '$target'. Use full path:" >&2
    for repo in "${matches[@]}"; do
      printf '  - %s\n' "$repo" >&2
    done
    exit 1
  fi

  for repo in "${matches[@]}"; do
    printf '%s\n' "$repo"
  done
}

do_checkout() {
  local reset=0
  while [[ "${1:-}" == "--reset" ]]; do
    reset=1
    shift
  done

  local rev="${1:-}"
  local target="${2:-}"

  if [[ -z "$rev" || -z "$target" ]]; then
    echo "Usage: ./repo checkout [--reset] <rev> <target>" >&2
    exit 1
  fi

  if [[ "$reset" -eq 1 && "${MODS_ASSUME_YES:-0}" != "1" ]]; then
    echo -e "${RED}WARNING:${NC} This will discard local changes and remove untracked files."
    echo -ne "${YELLOW}Continue? [y/N]: ${NC}"
    read -r confirm
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
      echo -e "${BLUE}Aborted.${NC}"
      exit 0
    fi
  fi

  local repo
  local failures=0
  while IFS= read -r repo; do
    [[ -z "$repo" ]] && continue
    echo -ne "  → $repo: "
    if ! git -C "$repo" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
      echo -e "${RED}missing${NC}"
      failures=$((failures + 1))
      continue
    fi

    if [[ "$reset" -eq 1 ]]; then
      git -C "$repo" reset --hard >/dev/null 2>&1 || true
      git -C "$repo" clean -fd >/dev/null 2>&1 || true
    fi

    if [[ "${MODS_FETCH:-1}" != "0" ]]; then
      local fetch_remote
      fetch_remote="$(resolve_remote_for_repo "$repo" "$repo")"
      if [[ -n "$fetch_remote" ]]; then
        git -C "$repo" fetch "$fetch_remote" --tags >/dev/null 2>&1 || true
      else
        git -C "$repo" fetch --tags >/dev/null 2>&1 || true
      fi
    fi

    if git -C "$repo" show-ref --verify --quiet "refs/heads/$rev"; then
      if git -C "$repo" checkout "$rev" >/dev/null 2>&1; then
        echo -e "${GREEN}checked out${NC}"
      else
        echo -e "${RED}failed${NC}"
        failures=$((failures + 1))
      fi
      continue
    fi

    local remote
    remote="$(resolve_remote_for_repo "$repo" "$repo")"
    if [[ -n "$remote" ]] && git -C "$repo" show-ref --verify --quiet "refs/remotes/$remote/$rev"; then
      if git -C "$repo" checkout -B "$rev" "$remote/$rev" >/dev/null 2>&1; then
        echo -e "${GREEN}checked out${NC}"
      else
        echo -e "${RED}failed${NC}"
        failures=$((failures + 1))
      fi
      continue
    fi

    if git -C "$repo" checkout "$rev" >/dev/null 2>&1; then
      echo -e "${GREEN}checked out${NC}"
    else
      echo -e "${RED}failed${NC}"
      failures=$((failures + 1))
    fi
  done < <(resolve_checkout_targets "$target")

  if [[ "$failures" -ne 0 ]]; then
    exit 1
  fi
}

do_lint() {
  local start_time=$SECONDS
  local dirty_repos=()
  local repo
  local force=0
  local verbose=0
  local lint_targets=()

  while [[ "$#" -gt 0 ]]; do
    case "$1" in
      --force)
        force=1
        ;;
      --verbose)
        verbose=1
        ;;
      --help|-h)
        echo "Usage: ./repo lint [--force] [--verbose] [targets...]"
        return 0
        ;;
      *)
        lint_targets+=("$1")
        ;;
    esac
    shift
  done

  if [[ "${#lint_targets[@]}" -gt 0 ]]; then
    REPO_TARGETS=()
    local target
    for target in "${lint_targets[@]}"; do
      case "$target" in
        self|.)
          add_target "."
          ;;
        all)
          while IFS= read -r path; do
            [[ -z "$path" ]] && continue
            add_target "$path"
          done < <(manifest_paths)
          ;;
        *)
          while IFS= read -r path; do
            [[ -z "$path" ]] && continue
            add_target "$path"
          done < <(resolve_checkout_targets "$target")
          ;;
      esac
    done
    dirty_repos=("${REPO_TARGETS[@]}")
  elif [[ "$force" -eq 1 ]]; then
    if [[ -x ./lint.sh ]]; then
      dirty_repos+=(".")
    fi
    while IFS= read -r repo; do
      [[ -z "$repo" ]] && continue
      if [[ -d "$repo/.git" || -f "$repo/.git" ]]; then
        dirty_repos+=("$repo")
      fi
    done < <(manifest_paths)
  else
    # Check root repo
    if [[ -n $(git status --porcelain 2>/dev/null || true) ]]; then
      dirty_repos+=(".")
    fi

    # Check all manifest repos
    while IFS= read -r repo; do
      [[ -z "$repo" ]] && continue
      if [[ -d "$repo/.git" || -f "$repo/.git" ]]; then
        if [[ -n $(git -C "$repo" status --porcelain 2>/dev/null || true) ]]; then
          dirty_repos+=("$repo")
        fi
      fi
    done < <(manifest_paths)

    if [[ ${#dirty_repos[@]} -eq 0 ]]; then
      echo -e "${GREEN}✓ No dirty repos${NC}"
      return 0
    fi
  fi

  local tmpdir
  tmpdir=$(mktemp -d)
  trap "rm -rf $tmpdir" EXIT

  local pids=()
  local repos_with_lint=()

  # Launch all lint.sh in parallel
  for repo in "${dirty_repos[@]}"; do
    local script=""
    local label="$repo"
    local use_just=0
    if [[ "$repo" == "." ]]; then
      script="./lint.sh"
      label="biovault-desktop"
    elif [[ "$repo" == "syft-crypto-core" ]]; then
      use_just=1
    else
      script="$repo/lint.sh"
    fi

    if [[ "$use_just" -eq 0 && ! -x "$script" ]]; then
      continue
    fi

    repos_with_lint+=("$repo")
    echo -e "${CYAN}→ $label${NC}"
    local outfile="$tmpdir/${repo//\//_}.out"
    (
      local task_start=$SECONDS
      if [[ "$use_just" -eq 1 ]]; then
        if (cd "$repo" && just lint-fix) > "$outfile" 2>&1; then
          echo "0" > "$outfile.status"
        else
          echo "1" > "$outfile.status"
        fi
      elif (cd "${repo:-.}" && ./lint.sh) > "$outfile" 2>&1; then
        echo "0" > "$outfile.status"
      else
        echo "1" > "$outfile.status"
      fi
      echo "$((SECONDS - task_start))" > "$outfile.time"
    ) &
    pids+=($!)
  done

  if [[ ${#repos_with_lint[@]} -eq 0 ]]; then
    echo -e "${GREEN}✓ No repos with lint.sh${NC}"
    return 0
  fi

  # Wait and collect results
  echo ""
  local failures=0
  local passed=0
  local i=0
  for pid in "${pids[@]}"; do
    wait "$pid" || true
    local repo="${repos_with_lint[$i]}"
    local label="$repo"
    [[ "$repo" == "." ]] && label="biovault-desktop"
    local outfile="$tmpdir/${repo//\//_}.out"
    local elapsed=""
    if [[ -f "$outfile.time" ]]; then
      elapsed=" ($(cat "$outfile.time")s)"
    fi

    if [[ -f "$outfile.status" && "$(cat "$outfile.status")" != "0" ]]; then
      echo -e "${RED}✗ $label${elapsed}${NC}"
      cat "$outfile"
      echo ""
      failures=$((failures + 1))
    elif [[ "$verbose" -eq 1 ]]; then
      echo -e "${GREEN}✓ $label${elapsed}${NC}"
      cat "$outfile"
      echo ""
      passed=$((passed + 1))
    else
      echo -e "${GREEN}✓ $label${elapsed}${NC}"
      passed=$((passed + 1))
    fi
    i=$((i + 1))
  done

  local total_time=$((SECONDS - start_time))
  echo ""
  if [[ "$failures" -eq 0 ]]; then
    echo -e "${GREEN}${passed} repos passed in ${total_time}s${NC}"
  else
    echo -e "${RED}${failures} failed, ${passed} passed in ${total_time}s${NC}"
    return 1
  fi
}

fast_tests_available() {
  case "$1" in
    syft-crypto-core)
      if [[ -d "$1/vendor/libsignal-protocol-syft/crates" ]]; then
        return 0
      fi
      return 1
      ;;
    "."|bioscript|biovault|biovault-beaver|sbenv|syftbox|syftbox-sdk)
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}

run_fast_tests() {
  local repo="$1"

  case "$repo" in
    ".")
      ./scripts/ensure-bundled-deps.sh
      cargo test --manifest-path src-tauri/Cargo.toml
      if compgen -G "tests/*.test.mjs" >/dev/null; then
        node --test tests/*.test.mjs
      fi
      ;;
    bioscript)
      (cd "$repo" && ./test.sh)
      ;;
    biovault)
      (cd "$repo/cli" && cargo test)
      ;;
    biovault-beaver)
      (cd "$repo" && ./test.sh)
      ;;
    sbenv)
      (cd "$repo/cli" && cargo test)
      ;;
    syft-crypto-core)
      (cd "$repo" && just test)
      ;;
    syftbox)
      (cd "$repo" && ./test.sh)
      ;;
    syftbox-sdk)
      (cd "$repo" && ./test.sh)
      ;;
    *)
      return 1
      ;;
  esac
}

do_test() {
  local start_time=$SECONDS
  local dirty_repos=()
  local repo
  local force=0
  local test_targets=()

  while [[ "$#" -gt 0 ]]; do
    case "$1" in
      --force)
        force=1
        ;;
      --help|-h)
        echo "Usage: ./repo test [--force] [targets...]"
        return 0
        ;;
      *)
        test_targets+=("$1")
        ;;
    esac
    shift
  done

  if [[ "${#test_targets[@]}" -gt 0 ]]; then
    REPO_TARGETS=()
    local target
    for target in "${test_targets[@]}"; do
      case "$target" in
        self|.)
          add_target "."
          ;;
        all)
          while IFS= read -r path; do
            [[ -z "$path" ]] && continue
            add_target "$path"
          done < <(manifest_paths)
          ;;
        *)
          while IFS= read -r path; do
            [[ -z "$path" ]] && continue
            add_target "$path"
          done < <(resolve_checkout_targets "$target")
          ;;
      esac
    done
    dirty_repos=("${REPO_TARGETS[@]}")
  elif [[ "$force" -eq 1 ]]; then
    dirty_repos+=(".")
    while IFS= read -r repo; do
      [[ -z "$repo" ]] && continue
      if [[ -d "$repo/.git" || -f "$repo/.git" ]]; then
        dirty_repos+=("$repo")
      fi
    done < <(manifest_paths)
  else
    # Check root repo
    if [[ -n $(git status --porcelain 2>/dev/null || true) ]]; then
      dirty_repos+=(".")
    fi

    # Check all manifest repos
    while IFS= read -r repo; do
      [[ -z "$repo" ]] && continue
      if [[ -d "$repo/.git" || -f "$repo/.git" ]]; then
        if [[ -n $(git -C "$repo" status --porcelain 2>/dev/null || true) ]]; then
          dirty_repos+=("$repo")
        fi
      fi
    done < <(manifest_paths)

    if [[ ${#dirty_repos[@]} -eq 0 ]]; then
      echo -e "${GREEN}✓ No dirty repos${NC}"
      return 0
    fi
  fi

  local tmpdir
  tmpdir=$(mktemp -d)
  trap "rm -rf $tmpdir" EXIT

  local pids=()
  local repos_with_tests=()

  for repo in "${dirty_repos[@]}"; do
    if ! fast_tests_available "$repo"; then
      continue
    fi

    repos_with_tests+=("$repo")
    local label="$repo"
    [[ "$repo" == "." ]] && label="biovault-desktop"
    echo -e "${CYAN}→ $label${NC}"
    local outfile="$tmpdir/${repo//\//_}.out"
    (
      local task_start=$SECONDS
      if run_fast_tests "$repo" > "$outfile" 2>&1; then
        echo "0" > "$outfile.status"
      else
        echo "1" > "$outfile.status"
      fi
      echo "$((SECONDS - task_start))" > "$outfile.time"
    ) &
    pids+=($!)
  done

  if [[ ${#repos_with_tests[@]} -eq 0 ]]; then
    echo -e "${GREEN}✓ No repos with fast tests${NC}"
    return 0
  fi

  local failures=0
  local passed=0
  local i=0
  for pid in "${pids[@]}"; do
    wait "$pid" || true
    local repo="${repos_with_tests[$i]}"
    local label="$repo"
    [[ "$repo" == "." ]] && label="biovault-desktop"
    local outfile="$tmpdir/${repo//\//_}.out"
    local elapsed=""
    if [[ -f "$outfile.time" ]]; then
      elapsed=" ($(cat "$outfile.time")s)"
    fi

    if [[ -f "$outfile.status" && "$(cat "$outfile.status")" != "0" ]]; then
      echo -e "${RED}✗ $label${elapsed}${NC}"
      cat "$outfile"
      echo ""
      failures=$((failures + 1))
    else
      echo -e "${GREEN}✓ $label${elapsed}${NC}"
      passed=$((passed + 1))
    fi
    i=$((i + 1))
  done

  local total_time=$((SECONDS - start_time))
  if [[ "$failures" -eq 0 ]]; then
    echo -e "${GREEN}${passed} repos passed in ${total_time}s${NC}"
  else
    echo -e "${RED}${failures} failed, ${passed} passed in ${total_time}s${NC}"
    return 1
  fi
}

do_check() {
  local start_time=$SECONDS
  local targets=("$@")

  if [[ ${#targets[@]} -eq 0 ]]; then
    echo "Usage: ./repo check <targets...>" >&2
    echo "Example: ./repo check syftbox syftbox-sdk" >&2
    exit 1
  fi

  local tmpdir
  tmpdir=$(mktemp -d)
  trap "rm -rf $tmpdir" EXIT

  local syft_crypto_requested=0
  local other_targets=()
  local target
  for target in "${targets[@]}"; do
    local resolved=""
    local is_syft_crypto=0
    if [[ "$target" == "syft-crypto-core" ]]; then
      is_syft_crypto=1
    else
      resolved=$(resolve_checkout_targets "$target" 2>/dev/null | head -1 || true)
      if [[ "$resolved" == "syft-crypto-core" ]]; then
        is_syft_crypto=1
      fi
    fi

    if [[ "$is_syft_crypto" -eq 1 ]]; then
      syft_crypto_requested=1
    else
      other_targets+=("$target")
    fi
  done

  echo -e "${CYAN}=== Check: lint + test ===${NC}"
  echo ""

  # Show what will be checked
  for target in "${targets[@]}"; do
    local repo_path
    repo_path=$(resolve_checkout_targets "$target" 2>/dev/null | head -1) || repo_path="$target"
    [[ "$repo_path" == "." ]] && repo_path="biovault-desktop"

    local lint_cmd="(none)"
    local test_cmd="(none)"
    local is_syft_crypto=0
    if [[ "$repo_path" == "syft-crypto-core" || "$target" == "syft-crypto-core" ]]; then
      is_syft_crypto=1
    fi

    if [[ "$is_syft_crypto" -eq 1 ]]; then
      lint_cmd="just lint-fix"
      test_cmd="just check-all"
    else
      if [[ -x "$target/lint.sh" || (-x "./lint.sh" && "$target" == ".") ]]; then
        lint_cmd="./lint.sh"
      fi

      case "$target" in
        "."|biovault-desktop)
          test_cmd="cargo test (src-tauri) + node --test"
          ;;
        syftbox)
          test_cmd="./test.sh (go test + cargo test rust/)"
          ;;
        syftbox-sdk)
          test_cmd="./test.sh (cargo test + cargo test --features embedded --test-threads=1)"
          ;;
        biovault)
          test_cmd="cargo test (cli)"
          ;;
        *)
          if [[ -x "$target/test.sh" ]]; then
            test_cmd="./test.sh"
          fi
          ;;
      esac
    fi

    echo -e "  ${CYAN}$repo_path${NC}"
    echo -e "    lint: ${BLUE}$lint_cmd${NC}"
    echo -e "    test: ${BLUE}$test_cmd${NC}"
  done
  echo ""

  local lint_pid=""
  local test_pid=""
  local syft_crypto_pid=""

  if [[ ${#other_targets[@]} -gt 0 ]]; then
    (
      do_lint "${other_targets[@]}" > "$tmpdir/lint.out" 2>&1
      echo $? > "$tmpdir/lint.status"
    ) &
    lint_pid=$!

    (
      do_test "${other_targets[@]}" > "$tmpdir/test.out" 2>&1
      echo $? > "$tmpdir/test.status"
    ) &
    test_pid=$!
  else
    echo "0" > "$tmpdir/lint.status"
    echo "0" > "$tmpdir/test.status"
    echo "Skipped (no non-syft-crypto-core targets)" > "$tmpdir/lint.out"
    echo "Skipped (no non-syft-crypto-core targets)" > "$tmpdir/test.out"
  fi

  if [[ "$syft_crypto_requested" -eq 1 ]]; then
    (
      (cd "syft-crypto-core" && just check-all) > "$tmpdir/syft-crypto-core-check.out" 2>&1
      echo $? > "$tmpdir/syft-crypto-core-check.status"
    ) &
    syft_crypto_pid=$!
  fi

  if [[ ${#other_targets[@]} -gt 0 && "$syft_crypto_requested" -eq 1 ]]; then
    echo -e "${YELLOW}Running lint/test + syft-crypto-core check-all in parallel...${NC}"
  elif [[ ${#other_targets[@]} -gt 0 ]]; then
    echo -e "${YELLOW}Running lint and test in parallel...${NC}"
  elif [[ "$syft_crypto_requested" -eq 1 ]]; then
    echo -e "${YELLOW}Running syft-crypto-core check-all...${NC}"
  fi
  echo ""

  # Wait for both
  if [[ -n "$lint_pid" ]]; then
    wait "$lint_pid" || true
  fi
  if [[ -n "$test_pid" ]]; then
    wait "$test_pid" || true
  fi
  if [[ -n "$syft_crypto_pid" ]]; then
    wait "$syft_crypto_pid" || true
  fi

  local lint_status=0
  local test_status=0
  local syft_crypto_status=0
  [[ -f "$tmpdir/lint.status" ]] && lint_status=$(cat "$tmpdir/lint.status")
  [[ -f "$tmpdir/test.status" ]] && test_status=$(cat "$tmpdir/test.status")
  [[ -f "$tmpdir/syft-crypto-core-check.status" ]] && syft_crypto_status=$(cat "$tmpdir/syft-crypto-core-check.status")

  # Report results
  echo -e "${CYAN}=== Lint Results ===${NC}"
  if [[ ${#other_targets[@]} -eq 0 ]]; then
    echo -e "${GREEN}✓ Lint skipped (no non-syft-crypto-core targets)${NC}"
  elif [[ "$lint_status" -eq 0 ]]; then
    echo -e "${GREEN}✓ Lint passed${NC}"
  else
    echo -e "${RED}✗ Lint failed${NC}"
    cat "$tmpdir/lint.out"
  fi

  echo ""
  echo -e "${CYAN}=== Test Results ===${NC}"
  if [[ ${#other_targets[@]} -eq 0 ]]; then
    echo -e "${GREEN}✓ Tests skipped (no non-syft-crypto-core targets)${NC}"
  elif [[ "$test_status" -eq 0 ]]; then
    echo -e "${GREEN}✓ Tests passed${NC}"
  else
    echo -e "${RED}✗ Tests failed${NC}"
    cat "$tmpdir/test.out"
  fi

  if [[ "$syft_crypto_requested" -eq 1 ]]; then
    echo ""
    echo -e "${CYAN}=== Syft Crypto Core Check-All Results ===${NC}"
    if [[ "$syft_crypto_status" -eq 0 ]]; then
      echo -e "${GREEN}✓ syft-crypto-core check-all passed${NC}"
    else
      echo -e "${RED}✗ syft-crypto-core check-all failed${NC}"
      cat "$tmpdir/syft-crypto-core-check.out"
    fi
  fi

  local total_time=$((SECONDS - start_time))
  echo ""
  if [[ "$lint_status" -eq 0 && "$test_status" -eq 0 && "$syft_crypto_status" -eq 0 ]]; then
    echo -e "${GREEN}✅ All checks passed in ${total_time}s${NC}"
  else
    echo -e "${RED}❌ Some checks failed in ${total_time}s${NC}"
    return 1
  fi
}

do_branch_dirty() {
  local branch="${1:-}"

  if [[ -z "$branch" ]]; then
    echo -e "${CYAN}=== Repos with uncommitted changes ===${NC}"
    echo ""

    local dirty_repos=()
    local repo

    # Check root repo
    if [[ -n $(git status --porcelain 2>/dev/null || true) ]]; then
      dirty_repos+=(".")
      echo -e "  ${RED}●${NC} ${CYAN}. (biovault-desktop)${NC} - dirty"
    fi

    # Check all manifest repos
    while IFS= read -r repo; do
      [[ -z "$repo" ]] && continue
      if [[ -d "$repo/.git" || -f "$repo/.git" ]]; then
        if [[ -n $(git -C "$repo" status --porcelain 2>/dev/null || true) ]]; then
          dirty_repos+=("$repo")
          echo -e "  ${RED}●${NC} ${CYAN}$repo${NC} - dirty"
        fi
      fi
    done < <(manifest_paths)

    echo ""
    if [[ ${#dirty_repos[@]} -eq 0 ]]; then
      echo -e "${GREEN}No repos have uncommitted changes.${NC}"
    else
      echo -e "${YELLOW}${#dirty_repos[@]} repo(s) have changes.${NC}"
      echo -e "Run: ${BLUE}./repo branch <branch-name>${NC} to create branches"
    fi
    return 0
  fi

  echo -e "${CYAN}=== Creating branch '$branch' in dirty repos ===${NC}"
  echo ""

  local dirty_repos=()
  local repo

  # Check root repo
  if [[ -n $(git status --porcelain 2>/dev/null || true) ]]; then
    dirty_repos+=(".")
  fi

  # Check all manifest repos
  while IFS= read -r repo; do
    [[ -z "$repo" ]] && continue
    if [[ -d "$repo/.git" || -f "$repo/.git" ]]; then
      if [[ -n $(git -C "$repo" status --porcelain 2>/dev/null || true) ]]; then
        dirty_repos+=("$repo")
      fi
    fi
  done < <(manifest_paths)

  if [[ ${#dirty_repos[@]} -eq 0 ]]; then
    echo -e "${GREEN}No repos have uncommitted changes. Nothing to do.${NC}"
    return 0
  fi

  echo -e "Creating branch in ${#dirty_repos[@]} repo(s):"
  echo ""

  local failures=0
  for repo in "${dirty_repos[@]}"; do
    local label="$repo"
    if [[ "$repo" == "." ]]; then
      label=". (biovault-desktop)"
    fi
    echo -ne "  → $label: "

    if [[ "$repo" == "." ]]; then
      if git checkout -B "$branch" >/dev/null 2>&1; then
        echo -e "${GREEN}created${NC}"
      else
        echo -e "${RED}failed${NC}"
        failures=$((failures + 1))
      fi
    else
      if git -C "$repo" checkout -B "$branch" >/dev/null 2>&1; then
        echo -e "${GREEN}created${NC}"
      else
        echo -e "${RED}failed${NC}"
        failures=$((failures + 1))
      fi
    fi
  done

  echo ""
  if [[ "$failures" -eq 0 ]]; then
    echo -e "${GREEN}✅ Branch '$branch' created in all dirty repos.${NC}"
    echo ""
    echo -e "Next steps:"
    echo -e "  1. ${BLUE}./repo commit -m \"message\"${NC}"
    echo -e "  2. ${BLUE}./repo push${NC}"
    echo -e "  3. ${BLUE}./repo pr${NC}"
  else
    echo -e "${RED}Failed to create branch in $failures repo(s).${NC}"
    return 1
  fi
}

do_commit() {
  local message=""
  while [[ "$#" -gt 0 ]]; do
    case "$1" in
      -m) message="$2"; shift 2 ;;
      *) shift ;;
    esac
  done

  if [[ -z "$message" ]]; then
    echo "Usage: ./repo commit -m \"message\"" >&2
    exit 1
  fi

  local dirty_repos=()
  local repo

  # Check root repo
  if [[ -n $(git status --porcelain 2>/dev/null || true) ]]; then
    dirty_repos+=(".")
  fi

  # Check all manifest repos
  while IFS= read -r repo; do
    [[ -z "$repo" ]] && continue
    if [[ -d "$repo/.git" || -f "$repo/.git" ]]; then
      if [[ -n $(git -C "$repo" status --porcelain 2>/dev/null || true) ]]; then
        dirty_repos+=("$repo")
      fi
    fi
  done < <(manifest_paths)

  if [[ ${#dirty_repos[@]} -eq 0 ]]; then
    echo -e "${GREEN}No repos have uncommitted changes.${NC}"
    return 0
  fi

  local failures=0
  for repo in "${dirty_repos[@]}"; do
    local label="$repo"
    [[ "$repo" == "." ]] && label="biovault-desktop"
    echo -ne "  → $label: "

    if [[ "$repo" == "." ]]; then
      git add -A >/dev/null 2>&1
      if git commit -m "$message" >/dev/null 2>&1; then
        echo -e "${GREEN}committed${NC}"
      else
        echo -e "${YELLOW}nothing to commit${NC}"
      fi
    else
      git -C "$repo" add -A >/dev/null 2>&1
      if git -C "$repo" commit -m "$message" >/dev/null 2>&1; then
        echo -e "${GREEN}committed${NC}"
      else
        echo -e "${YELLOW}nothing to commit${NC}"
      fi
    fi
  done

  if [[ "$failures" -eq 0 ]]; then
    echo -e "\n${GREEN}Done. Run: ${BLUE}./repo push${NC}"
  fi
}

do_push() {
  local repos_with_branches=()
  local repo

  # Check root repo
  local root_branch
  root_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")
  if [[ -n "$root_branch" && "$root_branch" != "main" && "$root_branch" != "HEAD" ]]; then
    repos_with_branches+=(".")
  fi

  # Check all manifest repos
  while IFS= read -r repo; do
    [[ -z "$repo" ]] && continue
    if [[ -d "$repo/.git" || -f "$repo/.git" ]]; then
      local branch
      branch=$(git -C "$repo" rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")
      if [[ -n "$branch" && "$branch" != "main" && "$branch" != "HEAD" ]]; then
        repos_with_branches+=("$repo")
      fi
    fi
  done < <(manifest_paths)

  if [[ ${#repos_with_branches[@]} -eq 0 ]]; then
    echo -e "${YELLOW}No repos on feature branches to push.${NC}"
    return 0
  fi

  local failures=0
  for repo in "${repos_with_branches[@]}"; do
    local label="$repo"
    local branch
    local remote
    if [[ "$repo" == "." ]]; then
      label="biovault-desktop"
      branch=$(git rev-parse --abbrev-ref HEAD)
      remote=$(git remote | head -1)
    else
      branch=$(git -C "$repo" rev-parse --abbrev-ref HEAD)
      remote=$(git -C "$repo" remote | head -1)
    fi
    echo -ne "  → $label ($branch): "

    if [[ -z "$remote" ]]; then
      echo -e "${RED}no remote${NC}"
      failures=$((failures + 1))
      continue
    fi

    if [[ "$repo" == "." ]]; then
      if git push -u "$remote" "$branch" >/dev/null 2>&1; then
        echo -e "${GREEN}pushed${NC}"
      else
        echo -e "${RED}failed${NC}"
        failures=$((failures + 1))
      fi
    else
      if git -C "$repo" push -u "$remote" "$branch" >/dev/null 2>&1; then
        echo -e "${GREEN}pushed${NC}"
      else
        echo -e "${RED}failed${NC}"
        failures=$((failures + 1))
      fi
    fi
  done

  if [[ "$failures" -eq 0 ]]; then
    echo -e "\n${GREEN}Done. Run: ${BLUE}./repo pr${NC}"
  else
    return 1
  fi
}

do_release() {
  echo -e "${CYAN}=== Pinning manifest to current HEADs ===${NC}"

  require_repo
  require_repo_workspace
  repo_pin

  if [[ -z $(git status --porcelain manifest.xml 2>/dev/null || true) ]]; then
    echo -e "${GREEN}Manifest already up to date.${NC}"
    return 0
  fi

  git add manifest.xml
  git commit -m "chore: pin dependencies"
  echo -e "${GREEN}✓ Manifest pinned and committed${NC}"
  echo -e "Run: ${BLUE}./repo push${NC} then ${BLUE}./repo pr${NC}"
}

do_pr() {
  local repos_with_branches=()
  local pr_urls=()
  local repo

  # Collect repos on feature branches
  local root_branch
  root_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")
  if [[ -n "$root_branch" && "$root_branch" != "main" && "$root_branch" != "HEAD" ]]; then
    repos_with_branches+=(".")
  fi

  while IFS= read -r repo; do
    [[ -z "$repo" ]] && continue
    if [[ -d "$repo/.git" || -f "$repo/.git" ]]; then
      local branch
      branch=$(git -C "$repo" rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")
      if [[ -n "$branch" && "$branch" != "main" && "$branch" != "HEAD" ]]; then
        repos_with_branches+=("$repo")
      fi
    fi
  done < <(manifest_paths)

  if [[ ${#repos_with_branches[@]} -eq 0 ]]; then
    echo -e "${YELLOW}No repos on feature branches.${NC}"
    return 0
  fi

  # Create PRs in dependency order (sub-repos first, then desktop)
  local sub_repos=()
  local has_root=0
  for repo in "${repos_with_branches[@]}"; do
    if [[ "$repo" == "." ]]; then
      has_root=1
    else
      sub_repos+=("$repo")
    fi
  done

  # Create PRs for sub-repos first
  for repo in "${sub_repos[@]}"; do
    local label="$repo"
    local branch
    branch=$(git -C "$repo" rev-parse --abbrev-ref HEAD)
    echo -ne "  → $label: "

    # Check if PR already exists
    local existing_pr
    existing_pr=$(cd "$repo" && gh pr view "$branch" --json url -q '.url' 2>/dev/null || echo "")
    if [[ -n "$existing_pr" ]]; then
      echo -e "${CYAN}exists${NC} $existing_pr"
      pr_urls+=("$existing_pr")
      continue
    fi

    local pr_url
    if pr_url=$(cd "$repo" && gh pr create --fill --head "$branch" 2>&1); then
      echo -e "${GREEN}created${NC} $pr_url"
      pr_urls+=("$pr_url")
    else
      echo -e "${RED}failed${NC}"
    fi
  done

  # Create PR for root (desktop) with links to dependent PRs
  if [[ "$has_root" -eq 1 ]]; then
    local branch
    branch=$(git rev-parse --abbrev-ref HEAD)
    echo -ne "  → biovault-desktop: "

    # Check if PR already exists
    local existing_pr
    existing_pr=$(gh pr view "$branch" --json url -q '.url' 2>/dev/null || echo "")
    if [[ -n "$existing_pr" ]]; then
      echo -e "${CYAN}exists${NC} $existing_pr"
      pr_urls+=("$existing_pr")
    else
      local body="## Summary\nChanges across workspace.\n\n"
      if [[ ${#pr_urls[@]} -gt 0 ]]; then
        body+="## Dependent PRs\n"
        for url in "${pr_urls[@]}"; do
          body+="- $url\n"
        done
      fi

      local pr_url
      if pr_url=$(gh pr create --title "$branch" --body "$(echo -e "$body")" --head "$branch" 2>&1); then
        echo -e "${GREEN}created${NC} $pr_url"
        pr_urls+=("$pr_url")
      else
        echo -e "${RED}failed${NC}"
      fi
    fi
  fi

  echo ""
  if [[ ${#pr_urls[@]} -gt 0 ]]; then
    echo -e "${GREEN}PRs:${NC}"
    for url in "${pr_urls[@]}"; do
      echo "  $url"
    done
  fi
}

do_switch() {
  local create=0
  if [[ "${1:-}" == "-b" ]]; then
    create=1
    shift
  fi

  local branch="${1:-}"
  shift || true

  if [[ -z "$branch" ]]; then
    echo "Usage: ./repo switch [-b] <branch> <targets...>" >&2
    exit 1
  fi

  local repo
  local failures=0
  while IFS= read -r repo; do
    [[ -z "$repo" ]] && continue
    local label="$repo"
    if [[ "$repo" == "$ROOT_DIR" ]]; then
      label="self"
    fi
    echo -ne "  → $label: "
    if ! git -C "$repo" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
      echo -e "${RED}missing${NC}"
      failures=$((failures + 1))
      continue
    fi

    if [[ -n $(git -C "$repo" status --porcelain -uno 2>/dev/null || true) ]]; then
      echo -e "${YELLOW}dirty (skipped)${NC}"
      continue
    fi

    if git -C "$repo" show-ref --verify --quiet "refs/heads/$branch"; then
      if git -C "$repo" checkout "$branch" >/dev/null 2>&1; then
        echo -e "${GREEN}switched${NC}"
      else
        echo -e "${RED}failed${NC}"
        failures=$((failures + 1))
      fi
      continue
    fi

    local remote
    remote="$(resolve_remote_for_repo "$repo" "$repo")"
    if [[ -n "$remote" ]] && git -C "$repo" show-ref --verify --quiet "refs/remotes/$remote/$branch"; then
      if git -C "$repo" checkout -b "$branch" "$remote/$branch" >/dev/null 2>&1; then
        echo -e "${GREEN}switched${NC}"
      else
        echo -e "${RED}failed${NC}"
        failures=$((failures + 1))
      fi
      continue
    fi

    if [[ "$create" -eq 1 ]]; then
      if git -C "$repo" checkout -b "$branch" >/dev/null 2>&1; then
        echo -e "${GREEN}created${NC}"
      else
        echo -e "${RED}failed${NC}"
        failures=$((failures + 1))
      fi
      continue
    fi

    echo -e "${RED}missing branch${NC}"
    failures=$((failures + 1))
  done < <(resolve_targets "$@")

  if [[ "$failures" -ne 0 ]]; then
    exit 1
  fi
}

case "${1:-}" in
  --init)
    require_repo
    repo_init "${2:-}"
    repo_sync
    if [[ -x "$ROOT_DIR/scripts/setup-repo-workspace.sh" ]]; then
      "$ROOT_DIR/scripts/setup-repo-workspace.sh"
    fi
    ;;
  sync)
    require_repo
    require_repo_workspace
    repo_sync "${@:2}"
    ;;
  fetch)
    repo_fetch "${@:2}"
    ;;
  pull)
    repo_pull "${2:-}"
    ;;
  ssh)
    repo_ssh
    ;;
  pin)
    require_repo
    require_repo_workspace
    repo_pin
    ;;
  main)
    do_checkout main all
    ;;
  --status)
    require_repo
    require_repo_workspace
    run_repo status
    ;;
  --branch)
    require_repo
    require_repo_workspace
    branch="${2:-}"
    if [[ -z "$branch" ]]; then
      echo "Missing branch name" >&2
      exit 1
    fi
    run_repo forall -c "git checkout -B \"$branch\""
    ;;
  branch)
    do_branch_dirty "${2:-}"
    ;;
  lint)
    do_lint "${@:2}"
    ;;
  test)
    do_test "${@:2}"
    ;;
  check)
    do_check "${@:2}"
    ;;
  commit)
    do_commit "${@:2}"
    ;;
  push)
    do_push
    ;;
  pr)
    do_pr
    ;;
  release)
    do_release
    ;;
  tools)
    repo_tools
    ;;
  --help|-h)
    usage
    ;;
  checkout)
    do_checkout "${@:2}"
    ;;
  switch)
    do_switch "${@:2}"
    ;;
  track)
    manifest_set_revision "${2:-}" "${3:-}"
    ;;
  "")
    show_tree
    ;;
  *)
    if [[ "$#" -eq 2 ]]; then
      manifest_set_revision "$1" "$2"
      exit 0
    fi
    echo "Unknown option: $1" >&2
    usage >&2
    exit 1
    ;;
esac
